<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shadow Legion: Eternal Wars - Enhanced 3D</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; color: #fff; font-family: 'Arial', sans-serif; }
        #gameCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100; }
        .ui-element { position: absolute; pointer-events: auto; }
        
        /* Main HUD */
        #healthBar { top: 20px; left: 20px; width: 300px; height: 30px; background: rgba(0,0,0,0.7); border: 2px solid #fff; border-radius: 5px; overflow: hidden; }
        #healthFill { height: 100%; background: linear-gradient(to right, #f00, #ff0); width: 100%; transition: width 0.3s; }
        #staminaBar { top: 60px; left: 20px; width: 300px; height: 20px; background: rgba(0,0,0,0.7); border: 2px solid #fff; border-radius: 5px; overflow: hidden; }
        #staminaFill { height: 100%; background: linear-gradient(to right, #0f0, #0ff); width: 100%; transition: width 0.3s; }
        #ammo { top: 90px; left: 20px; font-size: 20px; text-shadow: 2px 2px #000; }
        #weaponInfo { top: 120px; left: 20px; font-size: 16px; text-shadow: 2px 2px #000; }
        
        /* Abilities */
        #abilities { bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; }
        .ability { width: 60px; height: 60px; background: rgba(0,0,0,0.7); border: 2px solid #fff; border-radius: 10px; display: flex; align-items: center; justify-content: center; font-size: 24px; cursor: pointer; transition: all 0.2s; position: relative; }
        .ability:hover { background: rgba(255,255,255,0.2); transform: scale(1.1); }
        .ability.cooldown { opacity: 0.5; cursor: not-allowed; }
        .cooldown-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); border-radius: 8px; }
        
        /* Minimap */
        #minimap { top: 20px; right: 20px; width: 200px; height: 200px; background: rgba(0,0,0,0.7); border: 2px solid #fff; border-radius: 10px; overflow: hidden; }
        #minimapCanvas { width: 100%; height: 100%; }
        
        /* Quest Log */
        #questLog { bottom: 20px; right: 20px; width: 300px; background: rgba(0,0,0,0.7); border: 2px solid #fff; border-radius: 10px; padding: 15px; }
        #questLog h3 { margin: 0 0 10px 0; color: #ffd700; }
        #questLog ul { list-style: none; padding: 0; margin: 0; }
        #questLog li { padding: 5px 0; border-bottom: 1px solid rgba(255,255,255,0.2); }
        
        /* Crosshair */
        #crosshair { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 30px; height: 30px; pointer-events: none; }
        #crosshair::before, #crosshair::after { content: ''; position: absolute; background: #fff; }
        #crosshair::before { width: 100%; height: 2px; top: 50%; left: 0; transform: translateY(-50%); }
        #crosshair::after { width: 2px; height: 100%; top: 0; left: 50%; transform: translateX(-50%); }
        
        /* Vehicle HUD */
        #vehicleHUD { top: 120px; left: 20px; display: none; }
        .speedometer { font-size: 18px; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px; border: 2px solid #fff; }
        
        /* Damage Numbers */
        .damage-number { position: absolute; color: #ff0000; font-size: 24px; font-weight: bold; pointer-events: none; animation: damageFloat 1s ease-out forwards; }
        @keyframes damageFloat {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-50px); opacity: 0; }
        }
        
        /* UI Panels */
        #inventory { top: 50%; left: 50%; transform: translate(-50%, -50%); width: 700px; height: 500px; background: linear-gradient(135deg, rgba(0,0,0,0.9), rgba(20,20,20,0.9)); border: 2px solid #fff; border-radius: 15px; padding: 20px; display: none; box-shadow: 0 0 30px rgba(255,255,255,0.3); }
        #inventory h2 { margin: 0 0 20px 0; color: #ffd700; text-align: center; }
        #inventoryGrid { display: grid; grid-template-columns: repeat(6, 1fr); gap: 10px; margin-top: 20px; }
        .inventorySlot { width: 80px; height: 80px; background: rgba(255,255,255,0.1); border: 2px solid #666; border-radius: 10px; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; font-size: 30px; }
        .inventorySlot:hover { border-color: #fff; background: rgba(255,255,255,0.2); transform: scale(1.05); }
        
        #dialogueBox { bottom: 100px; left: 50%; transform: translateX(-50%); width: 800px; background: linear-gradient(135deg, rgba(0,0,0,0.9), rgba(20,20,20,0.9)); border: 2px solid #fff; border-radius: 15px; padding: 20px; display: none; box-shadow: 0 0 30px rgba(255,255,255,0.3); }
        #dialogueText { font-size: 18px; margin-bottom: 20px; line-height: 1.5; }
        #dialogueChoices { display: flex; flex-direction: column; gap: 10px; }
        .dialogueChoice { padding: 12px; background: rgba(255,255,255,0.1); border: 1px solid #666; border-radius: 8px; cursor: pointer; transition: all 0.2s; }
        .dialogueChoice:hover { background: rgba(255,255,255,0.2); border-color: #fff; }
        
        #worldMap { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); display: none; z-index: 200; }
        #mapContent { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 90%; height: 90%; background: url('https://picsum.photos/seed/fantasy-map/1600/900.jpg') center/cover; border: 3px solid #fff; border-radius: 15px; box-shadow: 0 0 50px rgba(255,255,255,0.5); }
        .mapLocation { position: absolute; width: 30px; height: 30px; background: #ff0000; border-radius: 50%; cursor: pointer; transition: all 0.2s; box-shadow: 0 0 20px rgba(255,0,0,0.8); }
        .mapLocation:hover { transform: scale(1.2); }
        
        #soundToggle { top: 20px; left: 50%; transform: translateX(-50%); padding: 10px 20px; background: rgba(0,0,0,0.7); border: 2px solid #fff; border-radius: 25px; cursor: pointer; transition: all 0.2s; }
        #soundToggle:hover { background: rgba(255,255,255,0.2); }
        
        #loadingScreen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(135deg, #000, #222); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000; }
        #loadingText { font-size: 32px; margin-bottom: 20px; color: #ffd700; }
        #loadingBar { width: 300px; height: 20px; background: rgba(255,255,255,0.2); border-radius: 10px; overflow: hidden; }
        #loadingProgress { height: 100%; background: linear-gradient(90deg, #ffd700, #ff6b6b); width: 0%; transition: width 0.3s; }
        
        /* Weapon Wheel */
        #weaponWheel { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 300px; height: 300px; display: none; pointer-events: auto; }
        .weapon-slot { position: absolute; width: 80px; height: 80px; background: rgba(0,0,0,0.7); border: 2px solid #fff; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; }
        .weapon-slot:hover { background: rgba(255,255,255,0.2); transform: scale(1.1); }
        .weapon-slot.selected { border-color: #ffd700; box-shadow: 0 0 20px rgba(255,215,0,0.8); }
    </style>
</head>
<body>
    <div id="loadingScreen">
        <div id="loadingText">Loading Shadow Legion: Eternal Wars...</div>
        <div id="loadingBar">
            <div id="loadingProgress"></div>
        </div>
    </div>
    
    <div id="gameCanvas"></div>
    <div id="ui">
        <!-- Main HUD -->
        <div id="healthBar" class="ui-element"><div id="healthFill"></div></div>
        <div id="staminaBar" class="ui-element"><div id="staminaFill"></div></div>
        <div id="ammo" class="ui-element">Ammo: 30/90</div>
        <div id="weaponInfo" class="ui-element">Weapon: Assault Rifle</div>
        
        <!-- Abilities -->
        <div id="abilities" class="ui-element">
            <div class="ability" data-ability="q">
                Q
                <div class="cooldown-overlay" style="height: 100%;"></div>
            </div>
            <div class="ability" data-ability="w">
                W
                <div class="cooldown-overlay" style="height: 100%;"></div>
            </div>
            <div class="ability" data-ability="e">
                E
                <div class="cooldown-overlay" style="height: 100%;"></div>
            </div>
            <div class="ability" data-ability="r">
                R
                <div class="cooldown-overlay" style="height: 100%;"></div>
            </div>
        </div>
        
        <!-- Minimap -->
        <div id="minimap" class="ui-element">
            <canvas id="minimapCanvas"></canvas>
        </div>
        
        <!-- Quest Log -->
        <div id="questLog" class="ui-element">
            <h3>Quests</h3>
            <ul id="questList">
                <li data-quest="1">[Active] Find the Lost Artifact</li>
                <li data-quest="2">[Active] Defeat the Shadow Boss</li>
            </ul>
        </div>
        
        <!-- Crosshair -->
        <div id="crosshair"></div>
        
        <!-- Vehicle HUD -->
        <div id="vehicleHUD" class="ui-element">
            <div class="speedometer">Speed: <span id="speed">0</span> km/h</div>
        </div>
        
        <!-- Inventory -->
        <div id="inventory" class="ui-element">
            <h2>Inventory</h2>
            <div id="inventoryGrid"></div>
            <button onclick="closeInventory()" style="margin-top: 20px; padding: 10px 20px; background: #ff6b6b; border: none; border-radius: 5px; color: white; cursor: pointer;">Close</button>
        </div>
        
        <!-- Dialogue -->
        <div id="dialogueBox" class="ui-element">
            <div id="dialogueText"></div>
            <div id="dialogueChoices"></div>
        </div>
        
        <!-- World Map -->
        <div id="worldMap">
            <div id="mapContent">
                <div class="mapLocation" style="top: 30%; left: 40%;" onclick="fastTravel('City')"></div>
                <div class="mapLocation" style="top: 60%; left: 70%;" onclick="fastTravel('Forest')"></div>
                <button onclick="closeMap()" style="position: absolute; top: 20px; right: 20px; padding: 10px 20px; background: #ff6b6b; border: none; border-radius: 5px; color: white; cursor: pointer;">Close</button>
            </div>
        </div>
        
        <!-- Weapon Wheel -->
        <div id="weaponWheel" class="ui-element">
            <div class="weapon-slot" style="top: 0; left: 50%; transform: translateX(-50%);" data-weapon="0">🔫</div>
            <div class="weapon-slot" style="top: 50%; right: 0; transform: translateY(-50%);" data-weapon="1">🔫</div>
            <div class="weapon-slot" style="bottom: 0; left: 50%; transform: translateX(-50%);" data-weapon="2">🔫</div>
            <div class="weapon-slot" style="top: 50%; left: 0; transform: translateY(-50%);" data-weapon="3">🔫</div>
        </div>
        
        <!-- Sound Toggle -->
        <div id="soundToggle" class="ui-element" onclick="toggleSound()">🔊 Sound ON</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Enhanced Game State
        const game = {
            scene: null,
            camera: null,
            renderer: null,
            player: {
                mesh: null,
                x: 0, y: 0, z: 0,
                yaw: 0, pitch: 0,
                health: 100, maxHealth: 100,
                stamina: 100, maxStamina: 100,
                ammo: 30, maxAmmo: 90,
                inVehicle: false,
                vehicle: null,
                inventory: [
                    { id: 1, name: 'Health Potion', type: 'consumable', icon: '🧪' },
                    { id: 2, name: 'Sword', type: 'weapon', icon: '⚔️' },
                    { id: 3, name: 'Key', type: 'quest', icon: '🗝️' }
                ],
                velocity: new THREE.Vector3(),
                isGrounded: false,
                isJumping: false,
                weapons: [
                    { name: 'Assault Rifle', damage: 25, ammo: 30, maxAmmo: 90, fireRate: 100, reloadTime: 2000 },
                    { name: 'Shotgun', damage: 50, ammo: 8, maxAmmo: 24, fireRate: 500, reloadTime: 3000 },
                    { name: 'Sniper Rifle', damage: 100, ammo: 5, maxAmmo: 15, fireRate: 1000, reloadTime: 4000 },
                    { name: 'Pistol', damage: 15, ammo: 12, maxAmmo: 48, fireRate: 200, reloadTime: 1500 }
                ],
                currentWeapon: 0,
                lastShot: 0,
                isReloading: false
            },
            keys: {},
            abilities: {
                q: { name: 'Fireball', cooldown: 0, maxCooldown: 5000, icon: '🔥' },
                w: { name: 'Heal', cooldown: 0, maxCooldown: 10000, icon: '💚' },
                e: { name: 'Dash', cooldown: 0, maxCooldown: 3000, icon: '💨' },
                r: { name: 'Ultimate', cooldown: 0, maxCooldown: 60000, icon: '💀' }
            },
            quests: [
                { id: 1, name: 'Find the Lost Artifact', completed: false },
                { id: 2, name: 'Defeat the Shadow Boss', completed: false }
            ],
            npcs: [],
            enemies: [],
            vehicles: [],
            particles: [],
            soundEnabled: true,
            currentDialogue: null,
            clock: new THREE.Clock(),
            raycaster: new THREE.Raycaster(),
            mouse: new THREE.Vector2(),
            audioListener: null,
            sounds: {},
            minimapCtx: null
        };

        // Loading simulation
        let loadingProgress = 0;
        const loadingInterval = setInterval(() => {
            loadingProgress += 10;
            document.getElementById('loadingProgress').style.width = loadingProgress + '%';
            if (loadingProgress >= 100) {
                clearInterval(loadingInterval);
                document.getElementById('loadingScreen').style.display = 'none';
                initThreeJS();
            }
        }, 200);

        // Initialize Three.js with enhancements
        function initThreeJS() {
            // Scene with fog
            game.scene = new THREE.Scene();
            game.scene.fog = new THREE.FogExp2(0x000000, 0.01);

            // Camera
            game.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            game.camera.position.set(0, 2, 0);

            // Renderer with antialiasing
            game.renderer = new THREE.WebGLRenderer({ antialias: true });
            game.renderer.setSize(window.innerWidth, window.innerHeight);
            game.renderer.shadowMap.enabled = true;
            game.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            game.renderer.toneMapping = THREE.ACESFilmicToneMapping;
            game.renderer.toneMappingExposure = 1.0;
            document.getElementById('gameCanvas').appendChild(game.renderer.domElement);

            // Audio Listener
            game.audioListener = new THREE.AudioListener();
            game.camera.add(game.audioListener);

            // Enhanced Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
            game.scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            game.scene.add(directionalLight);

            // Add hemisphere lighting for better ambient
            const hemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0x545454, 0.5);
            game.scene.add(hemisphereLight);

            // Skybox
            const skyboxGeometry = new THREE.BoxGeometry(1000, 1000, 1000);
            const skyboxMaterials = [
                new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('https://picsum.photos/seed/skybox-right/1024/1024.jpg'), side: THREE.BackSide }),
                new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('https://picsum.photos/seed/skybox-left/1024/1024.jpg'), side: THREE.BackSide }),
                new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('https://picsum.photos/seed/skybox-top/1024/1024.jpg'), side: THREE.BackSide }),
                new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('https://picsum.photos/seed/skybox-bottom/1024/1024.jpg'), side: THREE.BackSide }),
                new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('https://picsum.photos/seed/skybox-front/1024/1024.jpg'), side: THREE.BackSide }),
                new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('https://picsum.photos/seed/skybox-back/1024/1024.jpg'), side: THREE.BackSide })
            ];
            const skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterials);
            game.scene.add(skybox);

            // Create enhanced world
            createEnhancedWorld();
            createPlayer();
            createNPCs();
            createEnemies();
            createVehicles();
            initMinimap();
            initSounds();

            // Start game loop
            animate();
        }

        // Create enhanced world with better visuals
        function createEnhancedWorld() {
            // Ground with texture
            const groundGeometry = new THREE.PlaneGeometry(1000, 1000, 50, 50);
            const groundTexture = new THREE.TextureLoader().load('https://picsum.photos/seed/ground-texture/1024/1024.jpg');
            groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
            groundTexture.repeat.set(50, 50);
            const groundMaterial = new THREE.MeshLambertMaterial({ map: groundTexture });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            game.scene.add(ground);

            // Enhanced buildings with windows
            for (let i = 0; i < 20; i++) {
                const buildingGroup = new THREE.Group();
                
                const buildingGeometry = new THREE.BoxGeometry(
                    Math.random() * 20 + 10,
                    Math.random() * 30 + 10,
                    Math.random() * 20 + 10
                );
                const buildingMaterial = new THREE.MeshLambertMaterial({ 
                    color: new THREE.Color().setHSL(Math.random(), 0.5, 0.3) 
                });
                const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                building.castShadow = true;
                building.receiveShadow = true;
                buildingGroup.add(building);

                // Add windows
                const windowGeometry = new THREE.PlaneGeometry(2, 2);
                const windowMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00,
                    emissive: 0xffff00,
                    emissiveIntensity: 0.5
                });
                
                for (let j = 0; j < 10; j++) {
                    const window = new THREE.Mesh(windowGeometry, windowMaterial);
                    window.position.set(
                        (Math.random() - 0.5) * buildingGeometry.parameters.width * 0.8,
                        (Math.random() - 0.5) * buildingGeometry.parameters.height * 0.8,
                        buildingGeometry.parameters.depth / 2 + 0.1
                    );
                    buildingGroup.add(window);
                }

                buildingGroup.position.set(
                    (Math.random() - 0.5) * 200,
                    buildingGeometry.parameters.height / 2,
                    (Math.random() - 0.5) * 200
                );
                game.scene.add(buildingGroup);
            }

            // Enhanced trees
            for (let i = 0; i < 50; i++) {
                const treeGroup = new THREE.Group();
                
                const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.7, 5);
                const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                
                const leavesGeometry = new THREE.SphereGeometry(3);
                const leavesMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                leaves.position.y = 4;
                
                treeGroup.add(trunk);
                treeGroup.add(leaves);
                treeGroup.position.set(
                    (Math.random() - 0.5) * 300,
                    2.5,
                    (Math.random() - 0.5) * 300
                );
                treeGroup.castShadow = true;
                game.scene.add(treeGroup);
            }

            // Add some decorative elements
            for (let i = 0; i < 30; i++) {
                const rockGeometry = new THREE.DodecahedronGeometry(Math.random() * 2 + 0.5);
                const rockMaterial = new THREE.MeshLambertMaterial({ color: 0x696969 });
                const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                rock.position.set(
                    (Math.random() - 0.5) * 400,
                    0.5,
                    (Math.random() - 0.5) * 400
                );
                rock.castShadow = true;
                rock.receiveShadow = true;
                game.scene.add(rock);
            }
        }

        // Create player with physics
        function createPlayer() {
            const playerGeometry = new THREE.CapsuleGeometry(0.5, 1.8, 4, 8);
            const playerMaterial = new THREE.MeshLambertMaterial({ color: 0x0066cc });
            game.player.mesh = new THREE.Mesh(playerGeometry, playerMaterial);
            game.player.mesh.position.set(0, 1, 0);
            game.player.mesh.castShadow = true;
            game.scene.add(game.player.mesh);
        }

        // Create enhanced NPCs
        function createNPCs() {
            const npcData = [
                { name: 'Old Man', position: [10, 1, 10], color: 0x8B4513 },
                { name: 'Guard', position: [20, 1, 20], color: 0x696969 },
                { name: 'Merchant', position: [-15, 1, -15], color: 0x4B0082 }
            ];

            npcData.forEach(data => {
                const npcGroup = new THREE.Group();
                
                const npcGeometry = new THREE.CapsuleGeometry(0.5, 1.8, 4, 8);
                const npcMaterial = new THREE.MeshLambertMaterial({ color: data.color });
                const npc = new THREE.Mesh(npcGeometry, npcMaterial);
                npc.castShadow = true;
                npcGroup.add(npc);

                // Add name tag
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                context.fillStyle = 'white';
                context.font = '24px Arial';
                context.textAlign = 'center';
                context.fillText(data.name, 128, 40);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.y = 2;
                sprite.scale.set(4, 1, 1);
                npcGroup.add(sprite);
                
                npcGroup.position.set(...data.position);
                npcGroup.userData = { name: data.name, type: 'npc' };
                game.scene.add(npcGroup);
                game.npcs.push(npcGroup);
            });
        }

        // Create enhanced enemies with AI
        function createEnemies() {
            const enemyData = [
                { name: 'Shadow Warrior', position: [15, 1, 15], color: 0x4B0082, health: 100 },
                { name: 'Dark Archer', position: [25, 1, 25], color: 0x800080, health: 75 },
                { name: 'Shadow Beast', position: [-20, 1, -20], color: 0x8B0000, health: 150 }
            ];

            enemyData.forEach(data => {
                const enemyGroup = new THREE.Group();
                
                const enemyGeometry = new THREE.CapsuleGeometry(0.5, 1.8, 4, 8);
                const enemyMaterial = new THREE.MeshLambertMaterial({ color: data.color });
                const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
                enemy.castShadow = true;
                enemyGroup.add(enemy);

                // Add health bar
                const healthBarGeometry = new THREE.PlaneGeometry(2, 0.2);
                const healthBarMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                const healthBar = new THREE.Mesh(healthBarGeometry, healthBarMaterial);
                healthBar.position.y = 2.5;
                enemyGroup.add(healthBar);
                
                enemyGroup.position.set(...data.position);
                enemyGroup.userData = { 
                    name: data.name, 
                    type: 'enemy',
                    health: data.health,
                    maxHealth: data.health,
                    damage: 10,
                    healthBar: healthBar,
                    lastAttack: 0,
                    state: 'patrol',
                    patrolTarget: new THREE.Vector3(
                        data.position[0] + (Math.random() - 0.5) * 20,
                        1,
                        data.position[2] + (Math.random() - 0.5) * 20
                    )
                };
                game.scene.add(enemyGroup);
                game.enemies.push(enemyGroup);
            });
        }

        // Create enhanced vehicles
        function createVehicles() {
            const vehicleData = [
                { name: 'Motorcycle', position: [5, 0.5, 5], color: 0xFF0000 },
                { name: 'Car', position: [-10, 0.5, -10], color: 0x0000FF }
            ];

            vehicleData.forEach(data => {
                const vehicleGroup = new THREE.Group();
                
                if (data.name === 'Motorcycle') {
                    // Motorcycle
                    const bodyGeometry = new THREE.BoxGeometry(2, 0.5, 1);
                    const bodyMaterial = new THREE.MeshLambertMaterial({ color: data.color });
                    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                    body.position.y = 0.5;
                    body.castShadow = true;
                    
                    const wheelGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.2);
                    const wheelMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
                    
                    const wheel1 = new THREE.Mesh(wheelGeometry, wheelMaterial);
                    wheel1.rotation.z = Math.PI / 2;
                    wheel1.position.set(-0.8, 0.3, 0.5);
                    
                    const wheel2 = new THREE.Mesh(wheelGeometry, wheelMaterial);
                    wheel2.rotation.z = Math.PI / 2;
                    wheel2.position.set(0.8, 0.3, 0.5);
                    
                    vehicleGroup.add(body);
                    vehicleGroup.add(wheel1);
                    vehicleGroup.add(wheel2);
                } else {
                    // Car
                    const bodyGeometry = new THREE.BoxGeometry(4, 1.5, 2);
                    const bodyMaterial = new THREE.MeshLambertMaterial({ color: data.color });
                    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                    body.position.y = 0.75;
                    body.castShadow = true;
                    
                    const wheelGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.3);
                    const wheelMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
                    
                    const wheels = [];
                    const wheelPositions = [
                        [-1.5, 0.4, 1], [1.5, 0.4, 1],
                        [-1.5, 0.4, -1], [1.5, 0.4, -1]
                    ];
                    
                    wheelPositions.forEach(pos => {
                        const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                        wheel.rotation.z = Math.PI / 2;
                        wheel.position.set(...pos);
                        wheels.push(wheel);
                        vehicleGroup.add(wheel);
                    });
                    
                    vehicleGroup.add(body);
                }
                
                vehicleGroup.position.set(...data.position);
                vehicleGroup.userData = { 
                    name: data.name, 
                    type: 'vehicle',
                    speed: 0,
                    maxSpeed: data.name === 'Motorcycle' ? 150 : 100
                };
                
                game.scene.add(vehicleGroup);
                game.vehicles.push(vehicleGroup);
            });
        }

        // Initialize minimap
        function initMinimap() {
            const minimapCanvas = document.getElementById('minimapCanvas');
            minimapCanvas.width = 200;
            minimapCanvas.height = 200;
            game.minimapCtx = minimapCanvas.getContext('2d');
        }

        // Initialize sounds
        function initSounds() {
            // Create audio elements
            game.sounds.shoot = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIG2m98OScTgwOUarm7blmFgU7k9n1unEiBC13yO/eizEIHWq+8+OWT');
            game.sounds.reload = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIG2m98OScTgwOUarm7blmFgU7k9n1unEiBC13yO/eizEIHWq+8+OWT');
            game.sounds.footstep = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIG2m98OScTgwOUarm7blmFgU7k9n1unEiBC13yO/eizEIHWq+8+OWT');
        }

        // Enhanced input handling
        document.addEventListener('keydown', (e) => {
            game.keys[e.key.toLowerCase()] = true;
            
            if (e.key === ' ') shoot();
            if (e.key === 'r') reloadWeapon();
            if (e.key === 'i') openInventory();
            if (e.key === 'm') openMap();
            if (e.key === 'f') interact();
            if (e.key === 'Enter' && game.player.inVehicle) exitVehicle();
            if (e.key === 'Tab') {
                e.preventDefault();
                toggleWeaponWheel();
            }
            if (e.key >= '1' && e.key <= '4') {
                game.player.currentWeapon = parseInt(e.key) - 1;
                updateWeaponInfo();
            }
        });

        document.addEventListener('keyup', (e) => {
            game.keys[e.key.toLowerCase()] = false;
        });

        // Mouse look with sensitivity
        document.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement === game.renderer.domElement) {
                const sensitivity = 0.002;
                game.player.yaw -= e.movementX * sensitivity;
                game.player.pitch -= e.movementY * sensitivity;
                game.player.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, game.player.pitch));
            }
        });

        // Click to lock pointer
        game.renderer.domElement.addEventListener('click', () => {
            game.renderer.domElement.requestPointerLock();
        });

        // Enhanced shooting with recoil
        function shoot() {
            const weapon = game.player.weapons[game.player.currentWeapon];
            const now = Date.now();
            
            if (game.player.isReloading) return;
            if (now - game.player.lastShot < weapon.fireRate) return;
            if (weapon.ammo <= 0) {
                reloadWeapon();
                return;
            }
            
            weapon.ammo--;
            game.player.lastShot = now;
            updateAmmo();
            playSound('shoot');
            
            // Add recoil
            game.player.pitch += (Math.random() - 0.5) * 0.1;
            game.player.yaw += (Math.random() - 0.5) * 0.1;
            
            // Create muzzle flash
            createMuzzleFlash();
            
            // Raycast for shooting
            const direction = new THREE.Vector3();
            game.camera.getWorldDirection(direction);
            
            // Add bullet spread
            direction.x += (Math.random() - 0.5) * 0.1;
            direction.y += (Math.random() - 0.5) * 0.1;
            direction.z += (Math.random() - 0.5) * 0.1;
            direction.normalize();
            
            game.raycaster.set(game.camera.position, direction);
            const intersects = game.raycaster.intersectObjects(game.scene.children, true);
            
            if (intersects.length > 0) {
                const hit = intersects[0];
                if (hit.object.parent && hit.object.parent.userData.type === 'enemy') {
                    const enemy = hit.object.parent;
                    enemy.userData.health -= weapon.damage;
                    updateEnemyHealth(enemy);
                    showDamageNumber(hit.point, weapon.damage);
                    
                    if (enemy.userData.health <= 0) {
                        createExplosion(enemy.position);
                        game.scene.remove(enemy);
                        game.enemies = game.enemies.filter(e => e !== enemy);
                        console.log(`${enemy.userData.name} defeated!`);
                    }
                }
                
                // Create impact effect
                createImpactEffect(hit.point, hit.face.normal);
            }
        }

        // Reload weapon
        function reloadWeapon() {
            const weapon = game.player.weapons[game.player.currentWeapon];
            if (game.player.isReloading || weapon.ammo === weapon.maxAmmo) return;
            
            game.player.isReloading = true;
            playSound('reload');
            
            setTimeout(() => {
                weapon.ammo = weapon.maxAmmo;
                game.player.isReloading = false;
                updateAmmo();
            }, weapon.reloadTime);
        }

        // Enhanced movement with jumping and physics
        function updateMovement(deltaTime) {
            const speed = game.player.inVehicle ? 50 : (game.keys['shift'] ? 10 : 5);
            const direction = new THREE.Vector3();
            
            if (game.keys['w']) direction.z -= 1;
            if (game.keys['s']) direction.z += 1;
            if (game.keys['a']) direction.x -= 1;
            if (game.keys['d']) direction.x += 1;
            
            direction.normalize();
            direction.multiplyScalar(speed * deltaTime);
            
            // Apply rotation
            direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), game.player.yaw);
            
            // Update player position
            game.player.mesh.position.add(direction);
            game.camera.position.copy(game.player.mesh.position);
            game.camera.position.y += 1.8;
            
            // Jumping
            if (game.keys[' '] && game.player.isGrounded && !game.player.isJumping) {
                game.player.velocity.y = 8;
                game.player.isJumping = true;
                game.player.isGrounded = false;
            }
            
            // Apply gravity
            if (!game.player.isGrounded) {
                game.player.velocity.y -= 20 * deltaTime;
                game.player.mesh.position.y += game.player.velocity.y * deltaTime;
                
                if (game.player.mesh.position.y <= 1) {
                    game.player.mesh.position.y = 1;
                    game.player.velocity.y = 0;
                    game.player.isGrounded = true;
                    game.player.isJumping = false;
                }
            }
            
            // Update camera rotation
            game.camera.rotation.order = 'YXZ';
            game.camera.rotation.y = game.player.yaw;
            game.camera.rotation.x = game.player.pitch;
            
            // Stamina
            if (game.keys['shift'] && game.player.stamina > 0 && !game.player.inVehicle) {
                game.player.stamina -= 20 * deltaTime;
            } else if (game.player.stamina < game.player.maxStamina) {
                game.player.stamina += 10 * deltaTime;
            }
            updateStamina();
            
            // Footstep sounds
            if ((game.keys['w'] || game.keys['s'] || game.keys['a'] || game.keys['d']) && game.player.isGrounded) {
                if (Math.random() < 0.1) {
                    playSound('footstep');
                }
            }
        }

        // Enhanced enemy AI
        function updateEnemies(deltaTime) {
            game.enemies.forEach(enemy => {
                const distance = enemy.position.distanceTo(game.player.mesh.position);
                const now = Date.now();
                
                // State machine
                if (distance < 20) {
                    enemy.userData.state = 'chase';
                } else if (enemy.userData.state === 'chase' && distance > 30) {
                    enemy.userData.state = 'patrol';
                }
                
                if (enemy.userData.state === 'chase') {
                    // Move towards player
                    const direction = new THREE.Vector3()
                        .subVectors(game.player.mesh.position, enemy.position)
                        .normalize();
                    enemy.position.add(direction.multiplyScalar(3 * deltaTime));
                    
                    // Attack if close
                    if (distance < 3 && now - enemy.userData.lastAttack > 1000) {
                        takeDamage(enemy.userData.damage);
                        enemy.userData.lastAttack = now;
                    }
                } else if (enemy.userData.state === 'patrol') {
                    // Patrol movement
                    const patrolDistance = enemy.position.distanceTo(enemy.userData.patrolTarget);
                    if (patrolDistance < 2) {
                        enemy.userData.patrolTarget = new THREE.Vector3(
                            enemy.position.x + (Math.random() - 0.5) * 20,
                            1,
                            enemy.position.z + (Math.random() - 0.5) * 20
                        );
                    }
                    
                    const direction = new THREE.Vector3()
                        .subVectors(enemy.userData.patrolTarget, enemy.position)
                        .normalize();
                    enemy.position.add(direction.multiplyScalar(1 * deltaTime));
                }
                
                // Face the player when chasing
                if (enemy.userData.state === 'chase') {
                    enemy.lookAt(game.player.mesh.position);
                }
            });
        }

        // Particle effects
        function createMuzzleFlash() {
            const flashGeometry = new THREE.PlaneGeometry(0.5, 0.5);
            const flashMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffff00,
                transparent: true,
                opacity: 0.8
            });
            const flash = new THREE.Mesh(flashGeometry, flashMaterial);
            
            const direction = new THREE.Vector3();
            game.camera.getWorldDirection(direction);
            flash.position.copy(game.camera.position).add(direction.multiplyScalar(1));
            flash.lookAt(flash.position.clone().add(direction));
            
            game.scene.add(flash);
            
            setTimeout(() => {
                game.scene.remove(flash);
            }, 50);
        }

        function createImpactEffect(position, normal) {
            const particleCount = 10;
            const particles = new THREE.Group();
            
            for (let i = 0; i < particleCount; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.05);
                const particleMaterial = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                particle.position.copy(position);
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.2,
                    (Math.random() - 0.5) * 0.2,
                    (Math.random() - 0.5) * 0.2
                );
                
                particles.add(particle);
            }
            
            game.scene.add(particles);
            game.particles.push(particles);
        }

        function createExplosion(position) {
            const particleCount = 50;
            const particles = new THREE.Group();
            
            for (let i = 0; i < particleCount; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.1);
                const particleMaterial = new THREE.MeshBasicMaterial({ 
                    color: new THREE.Color().setHSL(Math.random() * 0.1, 1, 0.5)
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                particle.position.copy(position);
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.5,
                    Math.random() * 0.5,
                    (Math.random() - 0.5) * 0.5
                );
                
                particles.add(particle);
            }
            
            game.scene.add(particles);
            game.particles.push(particles);
        }

        function updateParticles(deltaTime) {
            game.particles.forEach((particles, index) => {
                let allDead = true;
                
                particles.children.forEach(particle => {
                    particle.position.add(particle.velocity);
                    particle.velocity.y -= 0.01;
                    particle.material.opacity -= 0.02;
                    
                    if (particle.material.opacity > 0) {
                        allDead = false;
                    }
                });
                
                if (allDead) {
                    game.scene.remove(particles);
                    game.particles.splice(index, 1);
                }
            });
        }

        // Update minimap
        function updateMinimap() {
            if (!game.minimapCtx) return;
            
            const ctx = game.minimapCtx;
            const scale = 0.5;
            
            // Clear minimap
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, 200, 200);
            
            // Draw player
            ctx.fillStyle = '#00ff00';
            ctx.beginPath();
            ctx.arc(100 + game.player.mesh.position.x * scale, 100 + game.player.mesh.position.z * scale, 3, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw enemies
            ctx.fillStyle = '#ff0000';
            game.enemies.forEach(enemy => {
                ctx.beginPath();
                ctx.arc(100 + enemy.position.x * scale, 100 + enemy.position.z * scale, 2, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Draw NPCs
            ctx.fillStyle = '#ffff00';
            game.npcs.forEach(npc => {
                ctx.beginPath();
                ctx.arc(100 + npc.position.x * scale, 100 + npc.position.z * scale, 2, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // UI Functions
        function showDamageNumber(position, damage) {
            const damageElement = document.createElement('div');
            damageElement.className = 'damage-number';
            damageElement.textContent = `-${damage}`;
            
            // Convert 3D position to screen position
            const vector = position.clone();
            vector.project(game.camera);
            
            const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
            
            damageElement.style.left = x + 'px';
            damageElement.style.top = y + 'px';
            
            document.getElementById('ui').appendChild(damageElement);
            
            setTimeout(() => {
                damageElement.remove();
            }, 1000);
        }

        function updateEnemyHealth(enemy) {
            const healthPercent = enemy.userData.health / enemy.userData.maxHealth;
            enemy.userData.healthBar.scale.x = healthPercent;
            enemy.userData.healthBar.material.color.setHSL(healthPercent * 0.3, 1, 0.5);
        }

        function updateWeaponInfo() {
            const weapon = game.player.weapons[game.player.currentWeapon];
            document.getElementById('weaponInfo').textContent = `Weapon: ${weapon.name}`;
        }

        function toggleWeaponWheel() {
            const wheel = document.getElementById('weaponWheel');
            wheel.style.display = wheel.style.display === 'none' ? 'block' : 'none';
            
            // Update selection
            document.querySelectorAll('.weapon-slot').forEach((slot, index) => {
                slot.classList.toggle('selected', index === game.player.currentWeapon);
            });
        }

        // Other UI functions (similar to before)
        function openInventory() {
            document.getElementById('inventory').style.display = 'block';
            renderInventory();
        }
        function closeInventory() {
            document.getElementById('inventory').style.display = 'none';
        }
        function renderInventory() {
            const grid = document.getElementById('inventoryGrid');
            grid.innerHTML = '';
            game.player.inventory.forEach((item, index) => {
                const slot = document.createElement('div');
                slot.className = 'inventorySlot';
                slot.innerHTML = item.icon;
                slot.onclick = () => useItem(item);
                grid.appendChild(slot);
            });
        }
        function useItem(item) {
            if (item.type === 'consumable') {
                console.log(`Used ${item.name}`);
                if (item.name === 'Health Potion') {
                    game.player.health = Math.min(game.player.maxHealth, game.player.health + 30);
                    updateHealth();
                }
                game.player.inventory = game.player.inventory.filter(i => i.id !== item.id);
                renderInventory();
            }
        }
        function interact() {
            const nearbyObjects = [...game.npcs, ...game.vehicles].filter(obj => 
                obj.position.distanceTo(game.player.mesh.position) < 5
            );
            
            if (nearbyObjects.length > 0) {
                const obj = nearbyObjects[0];
                if (obj.userData.type === 'npc') {
                    showDialogue(obj.userData);
                } else if (obj.userData.type === 'vehicle') {
                    enterVehicle(obj);
                }
            }
        }
        function showDialogue(npcData) {
            const dialogueBox = document.getElementById('dialogueBox');
            const dialogueText = document.getElementById('dialogueText');
            const dialogueChoices = document.getElementById('dialogueChoices');
            
            dialogueBox.style.display = 'block';
            dialogueText.textContent = `${npcData.name}: Greetings, traveler! How can I help you?`;
            dialogueChoices.innerHTML = '';
            
            const choices = [
                { text: 'Tell me about the area.', action: () => console.log('Area info') },
                { text: 'Do you have any quests?', action: () => console.log('Quests') },
                { text: 'Goodbye.', action: () => closeDialogue() }
            ];
            
            choices.forEach(choice => {
                const choiceEl = document.createElement('div');
                choiceEl.className = 'dialogueChoice';
                choiceEl.textContent = choice.text;
                choiceEl.onclick = choice.action;
                dialogueChoices.appendChild(choiceEl);
            });
        }
        function closeDialogue() {
            document.getElementById('dialogueBox').style.display = 'none';
        }
        function enterVehicle(vehicle) {
            game.player.inVehicle = true;
            game.player.vehicle = vehicle;
            document.getElementById('vehicleHUD').style.display = 'block';
            playSound('engine');
        }
        function exitVehicle() {
            game.player.inVehicle = false;
            game.player.vehicle = null;
            document.getElementById('vehicleHUD').style.display = 'none';
            playSound('door');
        }
        function openMap() {
            document.getElementById('worldMap').style.display = 'block';
        }
        function closeMap() {
            document.getElementById('worldMap').style.display = 'none';
        }
        function fastTravel(location) {
            console.log(`Fast traveling to ${location}`);
            game.player.mesh.position.set(
                Math.random() * 100 - 50,
                1,
                Math.random() * 100 - 50
            );
            closeMap();
        }
        function playSound(soundName) {
            if (!game.soundEnabled || !game.sounds[soundName]) return;
            game.sounds[soundName].currentTime = 0;
            game.sounds[soundName].play().catch(e => console.log('Sound play failed:', e));
        }
        function toggleSound() {
            game.soundEnabled = !game.soundEnabled;
            document.getElementById('soundToggle').textContent = 
                game.soundEnabled ? '🔊 Sound ON' : '🔇 Sound OFF';
        }
        function takeDamage(amount) {
            game.player.health -= amount;
            updateHealth();
            
            // Screen shake effect
            game.camera.rotation.x += (Math.random() - 0.5) * 0.1;
            game.camera.rotation.y += (Math.random() - 0.5) * 0.1;
            
            if (game.player.health <= 0) {
                console.log('You died! Respawning...');
                game.player.health = game.player.maxHealth;
                game.player.mesh.position.set(0, 1, 0);
                updateHealth();
            }
        }
        function updateHealth() {
            const percentage = (game.player.health / game.player.maxHealth) * 100;
            document.getElementById('healthFill').style.width = percentage + '%';
        }
        function updateStamina() {
            const percentage = (game.player.stamina / game.player.maxStamina) * 100;
            document.getElementById('staminaFill').style.width = percentage + '%';
        }
        function updateAmmo() {
            const weapon = game.player.weapons[game.player.currentWeapon];
            document.getElementById('ammo').textContent = `Ammo: ${weapon.ammo}/${weapon.maxAmmo}`;
        }

        // Enhanced game loop
        function animate() {
            requestAnimationFrame(animate);
            
            const deltaTime = game.clock.getDelta();
            
            updateMovement(deltaTime);
            updateEnemies(deltaTime);
            updateParticles(deltaTime);
            updateMinimap();
            
            // Update ability cooldowns
            Object.keys(game.abilities).forEach(key => {
                const ability = game.abilities[key];
                if (ability.cooldown > 0) {
                    ability.cooldown -= deltaTime * 1000;
                    const overlay = document.querySelector(`[data-ability="${key}"] .cooldown-overlay`);
                    if (overlay) {
                        const percent = Math.max(0, ability.cooldown / ability.maxCooldown);
                        overlay.style.height = (percent * 100) + '%';
                    }
                }
            });
            
            // Update vehicle speed
            if (game.player.inVehicle && game.player.vehicle) {
                game.player.vehicle.userData.speed = Math.min(
                    game.player.vehicle.userData.maxSpeed,
                    game.player.vehicle.userData.speed + 50 * deltaTime
                );
                document.getElementById('speed').textContent = Math.floor(game.player.vehicle.userData.speed);
            }
            
            game.renderer.render(game.scene, game.camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            game.camera.aspect = window.innerWidth / window.innerHeight;
            game.camera.updateProjectionMatrix();
            game.renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Test functions
        setTimeout(() => takeDamage(20), 2000);
        setTimeout(() => completeQuest(1), 5000);
        
        function completeQuest(questId) {
            const quest = game.quests.find(q => q.id === questId);
            if (quest && !quest.completed) {
                quest.completed = true;
                document.querySelector(`[data-quest="${questId}"]`).textContent = `[Completed] ${quest.name}`;
                console.log(`Quest completed: ${quest.name}`);
            }
        }
    </script>
</body>
</html>
