<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shadow Legion: Eternal Wars - Ultimate Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; color: #fff; font-family: 'Arial', sans-serif; }
        #gameCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100; }
        .ui-element { position: absolute; pointer-events: auto; }
        
        /* Main HUD */
        #healthBar { top: 20px; left: 20px; width: 300px; height: 30px; background: rgba(0,0,0,0.7); border: 2px solid #fff; border-radius: 5px; overflow: hidden; }
        #healthFill { height: 100%; background: linear-gradient(to right, #f00, #ff0); width: 100%; transition: width 0.3s; }
        #staminaBar { top: 60px; left: 20px; width: 300px; height: 20px; background: rgba(0,0,0,0.7); border: 2px solid #fff; border-radius: 5px; overflow: hidden; }
        #staminaFill { height: 100%; background: linear-gradient(to right, #0f0, #0ff); width: 100%; transition: width 0.3s; }
        #ammo { top: 90px; left: 20px; font-size: 20px; text-shadow: 2px 2px #000; }
        #weaponInfo { top: 120px; left: 20px; font-size: 16px; text-shadow: 2px 2px #000; }
        #levelInfo { top: 150px; left: 20px; font-size: 16px; text-shadow: 2px 2px #000; }
        
        /* Abilities */
        #abilities { bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; }
        .ability { width: 60px; height: 60px; background: rgba(0,0,0,0.7); border: 2px solid #fff; border-radius: 10px; display: flex; align-items: center; justify-content: center; font-size: 24px; cursor: pointer; transition: all 0.2s; position: relative; }
        .ability:hover { background: rgba(255,255,255,0.2); transform: scale(1.1); }
        .ability.cooldown { opacity: 0.5; cursor: not-allowed; }
        .cooldown-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); border-radius: 8px; }
        
        /* Minimap */
        #minimap { top: 20px; right: 20px; width: 200px; height: 200px; background: rgba(0,0,0,0.7); border: 2px solid #fff; border-radius: 10px; overflow: hidden; }
        #minimapCanvas { width: 100%; height: 100%; }
        
        /* Quest Log */
        #questLog { bottom: 20px; right: 20px; width: 300px; background: rgba(0,0,0,0.7); border: 2px solid #fff; border-radius: 10px; padding: 15px; }
        #questLog h3 { margin: 0 0 10px 0; color: #ffd700; }
        #questLog ul { list-style: none; padding: 0; margin: 0; }
        #questLog li { padding: 5px 0; border-bottom: 1px solid rgba(255,255,255,0.2); }
        
        /* Crosshair */
        #crosshair { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 30px; height: 30px; pointer-events: none; }
        #crosshair::before, #crosshair::after { content: ''; position: absolute; background: #fff; }
        #crosshair::before { width: 100%; height: 2px; top: 50%; left: 0; transform: translateY(-50%); }
        #crosshair::after { width: 2px; height: 100%; top: 0; left: 50%; transform: translateX(-50%); }
        
        /* Vehicle HUD */
        #vehicleHUD { top: 120px; left: 20px; display: none; }
        .speedometer { font-size: 18px; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px; border: 2px solid #fff; }
        
        /* Damage Numbers */
        .damage-number { position: absolute; color: #ff0000; font-size: 24px; font-weight: bold; pointer-events: none; animation: damageFloat 1s ease-out forwards; }
        @keyframes damageFloat {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-50px); opacity: 0; }
        }
        
        /* UI Panels */
        #inventory { top: 50%; left: 50%; transform: translate(-50%, -50%); width: 800px; height: 600px; background: linear-gradient(135deg, rgba(0,0,0,0.9), rgba(20,20,20,0.9)); border: 2px solid #fff; border-radius: 15px; padding: 20px; display: none; box-shadow: 0 0 30px rgba(255,255,255,0.3); }
        #inventory h2 { margin: 0 0 20px 0; color: #ffd700; text-align: center; }
        #inventoryTabs { display: flex; gap: 10px; margin-bottom: 20px; }
        .inventory-tab { padding: 10px 20px; background: rgba(255,255,255,0.1); border: 1px solid #666; border-radius: 5px; cursor: pointer; transition: all 0.2s; }
        .inventory-tab:hover { background: rgba(255,255,255,0.2); }
        .inventory-tab.active { background: rgba(255,215,0,0.3); border-color: #ffd700; }
        #inventoryContent { height: 400px; overflow-y: auto; }
        #inventoryGrid { display: grid; grid-template-columns: repeat(8, 1fr); gap: 10px; }
        .inventorySlot { width: 60px; height: 60px; background: rgba(255,255,255,0.1); border: 2px solid #666; border-radius: 10px; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; font-size: 24px; }
        .inventorySlot:hover { border-color: #fff; background: rgba(255,255,255,0.2); transform: scale(1.05); }
        .inventorySlot.equipped { border-color: #ffd700; box-shadow: 0 0 10px rgba(255,215,0,0.5); }
        
        #dialogueBox { bottom: 100px; left: 50%; transform: translateX(-50%); width: 800px; background: linear-gradient(135deg, rgba(0,0,0,0.9), rgba(20,20,20,0.9)); border: 2px solid #fff; border-radius: 15px; padding: 20px; display: none; box-shadow: 0 0 30px rgba(255,255,255,0.3); }
        #dialogueText { font-size: 18px; margin-bottom: 20px; line-height: 1.5; }
        #dialogueChoices { display: flex; flex-direction: column; gap: 10px; }
        .dialogueChoice { padding: 12px; background: rgba(255,255,255,0.1); border: 1px solid #666; border-radius: 8px; cursor: pointer; transition: all 0.2s; }
        .dialogueChoice:hover { background: rgba(255,255,255,0.2); border-color: #fff; }
        
        #worldMap { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); display: none; z-index: 200; }
        #mapContent { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 90%; height: 90%; background: url('https://picsum.photos/seed/fantasy-map/1600/900.jpg') center/cover; border: 3px solid #fff; border-radius: 15px; box-shadow: 0 0 50px rgba(255,255,255,0.5); }
        .mapLocation { position: absolute; width: 30px; height: 30px; background: #ff0000; border-radius: 50%; cursor: pointer; transition: all 0.2s; box-shadow: 0 0 20px rgba(255,0,0,0.8); }
        .mapLocation:hover { transform: scale(1.2); }
        
        #soundToggle { top: 20px; left: 50%; transform: translateX(-50%); padding: 10px 20px; background: rgba(0,0,0,0.7); border: 2px solid #fff; border-radius: 25px; cursor: pointer; transition: all 0.2s; }
        #soundToggle:hover { background: rgba(255,255,255,0.2); }
        
        #loadingScreen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(135deg, #000, #222); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000; }
        #loadingText { font-size: 32px; margin-bottom: 20px; color: #ffd700; }
        #loadingBar { width: 300px; height: 20px; background: rgba(255,255,255,0.2); border-radius: 10px; overflow: hidden; }
        #loadingProgress { height: 100%; background: linear-gradient(90deg, #ffd700, #ff6b6b); width: 0%; transition: width 0.3s; }
        
        /* Game Mode Selection */
        #gameModeSelect { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 600px; background: rgba(0,0,0,0.9); border: 2px solid #fff; border-radius: 15px; padding: 30px; display: none; z-index: 300; }
        #gameModeSelect h2 { text-align: center; margin-bottom: 30px; color: #ffd700; }
        .gameMode { padding: 20px; margin: 10px 0; background: rgba(255,255,255,0.1); border: 2px solid #666; border-radius: 10px; cursor: pointer; transition: all 0.2s; text-align: center; }
        .gameMode:hover { background: rgba(255,255,255,0.2); border-color: #fff; transform: scale(1.02); }
        
        /* Skill Tree */
        #skillTree { top: 50%; left: 50%; transform: translate(-50%, -50%); width: 900px; height: 600px; background: rgba(0,0,0,0.9); border: 2px solid #fff; border-radius: 15px; padding: 20px; display: none; box-shadow: 0 0 30px rgba(255,255,255,0.3); }
        #skillTree h2 { text-align: center; color: #ffd700; margin-bottom: 20px; }
        .skill-tree-container { display: flex; justify-content: space-around; height: 500px; }
        .skill-branch { flex: 1; margin: 0 10px; }
        .skill-branch h3 { text-align: center; color: #fff; margin-bottom: 20px; }
        .skill-node { width: 60px; height: 60px; background: rgba(255,255,255,0.1); border: 2px solid #666; border-radius: 50%; margin: 10px auto; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; position: relative; }
        .skill-node:hover { background: rgba(255,255,255,0.2); border-color: #fff; transform: scale(1.1); }
        .skill-node.unlocked { border-color: #ffd700; background: rgba(255,215,0,0.3); }
        .skill-node.available { border-color: #0f0; }
        .skill-points { position: absolute; top: 20px; right: 20px; font-size: 18px; color: #ffd700; }
        
        /* Crafting */
        #crafting { top: 50%; left: 50%; transform: translate(-50%, -50%); width: 800px; height: 600px; background: rgba(0,0,0,0.9); border: 2px solid #fff; border-radius: 15px; padding: 20px; display: none; }
        #crafting h2 { text-align: center; color: #ffd700; margin-bottom: 20px; }
        #craftingGrid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; margin-top: 20px; }
        .crafting-recipe { padding: 15px; background: rgba(255,255,255,0.1); border: 2px solid #666; border-radius: 10px; cursor: pointer; transition: all 0.2s; }
        .crafting-recipe:hover { background: rgba(255,255,255,0.2); border-color: #fff; }
        .crafting-recipe h4 { margin: 0 0 10px 0; color: #ffd700; }
        .crafting-recipe .ingredients { font-size: 14px; color: #ccc; }
        
        /* Companion HUD */
        #companionHUD { bottom: 200px; left: 20px; width: 200px; background: rgba(0,0,0,0.7); border: 2px solid #fff; border-radius: 10px; padding: 10px; display: none; }
        #companionHealth { width: 100%; height: 10px; background: #333; border-radius: 5px; overflow: hidden; margin-top: 5px; }
        #companionHealthFill { height: 100%; background: #0f0; width: 100%; }
        
        /* Weather Effects */
        #weatherOverlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 50; }
        .rain-drop { position: absolute; width: 2px; height: 20px; background: rgba(255,255,255,0.3); animation: rain-fall linear infinite; }
        @keyframes rain-fall {
            to { transform: translateY(100vh); }
        }
        
        /* Base Building */
        #buildMenu { top: 50%; left: 50%; transform: translate(-50%, -50%); width: 600px; background: rgba(0,0,0,0.9); border: 2px solid #fff; border-radius: 15px; padding: 20px; display: none; }
        #buildMenu h2 { text-align: center; color: #ffd700; margin-bottom: 20px; }
        #buildOptions { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; }
        .build-option { padding: 15px; background: rgba(255,255,255,0.1); border: 2px solid #666; border-radius: 10px; cursor: pointer; transition: all 0.2s; text-align: center; }
        .build-option:hover { background: rgba(255,255,255,0.2); border-color: #fff; }
        
        /* Multiplayer HUD */
        #multiplayerHUD { top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.7); border: 2px solid #fff; border-radius: 10px; padding: 10px 20px; display: none; }
        #playerList { display: flex; gap: 20px; }
        .player-info { display: flex; align-items: center; gap: 10px; }
        .player-status { width: 10px; height: 10px; border-radius: 50%; background: #0f0; }
        
        /* Save/Load Menu */
        #saveLoadMenu { top: 50%; left: 50%; transform: translate(-50%, -50%); width: 500px; background: rgba(0,0,0,0.9); border: 2px solid #fff; border-radius: 15px; padding: 20px; display: none; }
        #saveLoadMenu h2 { text-align: center; color: #ffd700; margin-bottom: 20px; }
        .save-slot { padding: 15px; margin: 10px 0; background: rgba(255,255,255,0.1); border: 2px solid #666; border-radius: 10px; cursor: pointer; transition: all 0.2s; }
        .save-slot:hover { background: rgba(255,255,255,0.2); border-color: #fff; }
    </style>
</head>
<body>
    <div id="loadingScreen">
        <div id="loadingText">Loading Shadow Legion: Eternal Wars - Ultimate Edition...</div>
        <div id="loadingBar">
            <div id="loadingProgress"></div>
        </div>
    </div>
    
    <div id="gameCanvas"></div>
    <div id="ui">
        <!-- Main HUD -->
        <div id="healthBar" class="ui-element"><div id="healthFill"></div></div>
        <div id="staminaBar" class="ui-element"><div id="staminaFill"></div></div>
        <div id="ammo" class="ui-element">Ammo: 30/90</div>
        <div id="weaponInfo" class="ui-element">Weapon: Assault Rifle</div>
        <div id="levelInfo" class="ui-element">Level: 1 | XP: 0/100</div>
        
        <!-- Abilities -->
        <div id="abilities" class="ui-element">
            <div class="ability" data-ability="q">
                Q
                <div class="cooldown-overlay" style="height: 100%;"></div>
            </div>
            <div class="ability" data-ability="w">
                W
                <div class="cooldown-overlay" style="height: 100%;"></div>
            </div>
            <div class="ability" data-ability="e">
                E
                <div class="cooldown-overlay" style="height: 100%;"></div>
            </div>
            <div class="ability" data-ability="r">
                R
                <div class="cooldown-overlay" style="height: 100%;"></div>
            </div>
        </div>
        
        <!-- Minimap -->
        <div id="minimap" class="ui-element">
            <canvas id="minimapCanvas"></canvas>
        </div>
        
        <!-- Quest Log -->
        <div id="questLog" class="ui-element">
            <h3>Quests</h3>
            <ul id="questList">
                <li data-quest="1">[Active] Find the Lost Artifact</li>
                <li data-quest="2">[Active] Defeat the Shadow Boss</li>
            </ul>
        </div>
        
        <!-- Crosshair -->
        <div id="crosshair"></div>
        
        <!-- Vehicle HUD -->
        <div id="vehicleHUD" class="ui-element">
            <div class="speedometer">Speed: <span id="speed">0</span> km/h</div>
        </div>
        
        <!-- Companion HUD -->
        <div id="companionHUD" class="ui-element">
            <h4>Companion</h4>
            <div id="companionHealth"><div id="companionHealthFill"></div></div>
        </div>
        
        <!-- Multiplayer HUD -->
        <div id="multiplayerHUD" class="ui-element">
            <div id="playerList"></div>
        </div>
        
        <!-- Inventory -->
        <div id="inventory" class="ui-element">
            <h2>Inventory</h2>
            <div id="inventoryTabs">
                <div class="inventory-tab active" onclick="switchInventoryTab('items')">Items</div>
                <div class="inventory-tab" onclick="switchInventoryTab('weapons')">Weapons</div>
                <div class="inventory-tab" onclick="switchInventoryTab('armor')">Armor</div>
                <div class="inventory-tab" onclick="switchInventoryTab('crafting')">Crafting</div>
            </div>
            <div id="inventoryContent">
                <div id="inventoryGrid"></div>
            </div>
            <button onclick="closeInventory()" style="margin-top: 20px; padding: 10px 20px; background: #ff6b6b; border: none; border-radius: 5px; color: white; cursor: pointer;">Close</button>
        </div>
        
        <!-- Dialogue -->
        <div id="dialogueBox" class="ui-element">
            <div id="dialogueText"></div>
            <div id="dialogueChoices"></div>
        </div>
        
        <!-- World Map -->
        <div id="worldMap">
            <div id="mapContent">
                <div class="mapLocation" style="top: 30%; left: 40%;" onclick="fastTravel('City')"></div>
                <div class="mapLocation" style="top: 60%; left: 70%;" onclick="fastTravel('Forest')"></div>
                <button onclick="closeMap()" style="position: absolute; top: 20px; right: 20px; padding: 10px 20px; background: #ff6b6b; border: none; border-radius: 5px; color: white; cursor: pointer;">Close</button>
            </div>
        </div>
        
        <!-- Game Mode Selection -->
        <div id="gameModeSelect">
            <h2>Select Game Mode</h2>
            <div class="gameMode" onclick="startGameMode('story')">
                <h3>Story Mode</h3>
                <p>Experience the epic single-player campaign</p>
            </div>
            <div class="gameMode" onclick="startGameMode('coop')">
                <h3>Co-op Mode</h3>
                <p>Team up with friends to complete missions</p>
            </div>
            <div class="gameMode" onclick="startGameMode('pvp')">
                <h3>PvP Arena</h3>
                <p>Battle against other players</p>
            </div>
            <div class="gameMode" onclick="startGameMode('battleroyale')">
                <h3>Battle Royale</h3>
                <p>Survive against 100 players</p>
            </div>
        </div>
        
        <!-- Skill Tree -->
        <div id="skillTree" class="ui-element">
            <h2>Skill Tree</h2>
            <div class="skill-points">Skill Points: <span id="skillPoints">0</span></div>
            <div class="skill-tree-container">
                <div class="skill-branch">
                    <h3>Combat</h3>
                    <div class="skill-node" data-skill="damage" data-cost="1">‚öîÔ∏è</div>
                    <div class="skill-node" data-skill="speed" data-cost="1">‚ö°</div>
                    <div class="skill-node" data-skill="critical" data-cost="2">üí•</div>
                </div>
                <div class="skill-branch">
                    <h3>Magic</h3>
                    <div class="skill-node" data-skill="fireball" data-cost="1">üî•</div>
                    <div class="skill-node" data-skill="heal" data-cost="1">üíö</div>
                    <div class="skill-node" data-skill="teleport" data-cost="2">‚ú®</div>
                </div>
                <div class="skill-branch">
                    <h3>Stealth</h3>
                    <div class="skill-node" data-skill="invisibility" data-cost="1">üëª</div>
                    <div class="skill-node" data-skill="lockpick" data-cost="1">üîì</div>
                    <div class="skill-node" data-skill="assassinate" data-cost="2">üó°Ô∏è</div>
                </div>
            </div>
            <button onclick="closeSkillTree()" style="margin-top: 20px; padding: 10px 20px; background: #ff6b6b; border: none; border-radius: 5px; color: white; cursor: pointer;">Close</button>
        </div>
        
        <!-- Crafting -->
        <div id="crafting" class="ui-element">
            <h2>Crafting</h2>
            <div id="craftingGrid">
                <div class="crafting-recipe" onclick="craftItem('health_potion')">
                    <h4>Health Potion</h4>
                    <div class="ingredients">Herbs x2, Bottle x1</div>
                </div>
                <div class="crafting-recipe" onclick="craftItem('ammo')">
                    <h4>Ammo Box</h4>
                    <div class="ingredients">Metal x3, Gunpowder x2</div>
                </div>
                <div class="crafting-recipe" onclick="craftItem('weapon_upgrade')">
                    <h4>Weapon Upgrade</h4>
                    <div class="ingredients">Scrap Metal x5, Crystal x1</div>
                </div>
                <div class="crafting-recipe" onclick="craftItem('armor')">
                    <h4>Armor Piece</h4>
                    <div class="ingredients">Leather x3, Metal x2</div>
                </div>
            </div>
            <button onclick="closeCrafting()" style="margin-top: 20px; padding: 10px 20px; background: #ff6b6b; border: none; border-radius: 5px; color: white; cursor: pointer;">Close</button>
        </div>
        
        <!-- Build Menu -->
        <div id="buildMenu" class="ui-element">
            <h2>Build Structure</h2>
            <div id="buildOptions">
                <div class="build-option" onclick="buildStructure('wall')">
                    <h4>Wall</h4>
                    <p>Wood x5</p>
                </div>
                <div class="build-option" onclick="buildStructure('tower')">
                    <h4>Guard Tower</h4>
                    <p>Wood x10, Metal x5</p>
                </div>
                <div class="build-option" onclick="buildStructure('workshop')">
                    <h4>Workshop</h4>
                    <p>Wood x20, Metal x10</p>
                </div>
                <div class="build-option" onclick="buildStructure('storage')">
                    <h4>Storage</h4>
                    <p>Wood x15</p>
                </div>
                <div class="build-option" onclick="buildStructure('farm')">
                    <h4>Farm</h4>
                    <p>Seeds x5, Wood x10</p>
                </div>
                <div class="build-option" onclick="buildStructure('barracks')">
                    <h4>Barracks</h4>
                    <p>Wood x30, Metal x20</p>
                </div>
            </div>
            <button onclick="closeBuildMenu()" style="margin-top: 20px; padding: 10px 20px; background: #ff6b6b; border: none; border-radius: 5px; color: white; cursor: pointer;">Close</button>
        </div>
        
        <!-- Save/Load Menu -->
        <div id="saveLoadMenu" class="ui-element">
            <h2>Save/Load Game</h2>
            <div class="save-slot" onclick="saveGame(1)">
                <h4>Save Slot 1</h4>
                <p id="save1-info">Empty</p>
            </div>
            <div class="save-slot" onclick="saveGame(2)">
                <h4>Save Slot 2</h4>
                <p id="save2-info">Empty</p>
            </div>
            <div class="save-slot" onclick="saveGame(3)">
                <h4>Save Slot 3</h4>
                <p id="save3-info">Empty</p>
            </div>
            <button onclick="closeSaveLoadMenu()" style="margin-top: 20px; padding: 10px 20px; background: #ff6b6b; border: none; border-radius: 5px; color: white; cursor: pointer;">Close</button>
        </div>
        
        <!-- Weather Overlay -->
        <div id="weatherOverlay"></div>
        
        <!-- Sound Toggle -->
        <div id="soundToggle" class="ui-element" onclick="toggleSound()">üîä Sound ON</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script>
        // Ultimate Game State
        const game = {
            scene: null,
            camera: null,
            renderer: null,
            world: null,
            player: {
                mesh: null,
                body: null,
                x: 0, y: 0, z: 0,
                yaw: 0, pitch: 0,
                health: 100, maxHealth: 100,
                stamina: 100, maxStamina: 100,
                ammo: 30, maxAmmo: 90,
                inVehicle: false,
                vehicle: null,
                inventory: [
                    { id: 1, name: 'Health Potion', type: 'consumable', icon: 'üß™', quantity: 3 },
                    { id: 2, name: 'Sword', type: 'weapon', icon: '‚öîÔ∏è', equipped: true },
                    { id: 3, name: 'Key', type: 'quest', icon: 'üóùÔ∏è', quantity: 1 },
                    { id: 4, name: 'Herbs', type: 'crafting', icon: 'üåø', quantity: 5 },
                    { id: 5, name: 'Metal', type: 'crafting', icon: 'üîß', quantity: 10 },
                    { id: 6, name: 'Wood', type: 'crafting', icon: 'ü™µ', quantity: 15 }
                ],
                velocity: new THREE.Vector3(),
                isGrounded: false,
                isJumping: false,
                weapons: [
                    { name: 'Assault Rifle', damage: 25, ammo: 30, maxAmmo: 90, fireRate: 100, reloadTime: 2000, level: 1 },
                    { name: 'Shotgun', damage: 50, ammo: 8, maxAmmo: 24, fireRate: 500, reloadTime: 3000, level: 1 },
                    { name: 'Sniper Rifle', damage: 100, ammo: 5, maxAmmo: 15, fireRate: 1000, reloadTime: 4000, level: 1 },
                    { name: 'Pistol', damage: 15, ammo: 12, maxAmmo: 48, fireRate: 200, reloadTime: 1500, level: 1 }
                ],
                currentWeapon: 0,
                lastShot: 0,
                isReloading: false,
                level: 1,
                xp: 0,
                xpToNext: 100,
                skillPoints: 0,
                skills: {
                    damage: 0,
                    speed: 0,
                    critical: 0,
                    fireball: 0,
                    heal: 0,
                    teleport: 0,
                    invisibility: 0,
                    lockpick: 0,
                    assassinate: 0
                },
                companion: null,
                base: {
                    structures: [],
                    resources: {
                        wood: 100,
                        metal: 50,
                        food: 30
                    }
                }
            },
            keys: {},
            abilities: {
                q: { name: 'Fireball', cooldown: 0, maxCooldown: 5000, icon: 'üî•', unlocked: false },
                w: { name: 'Heal', cooldown: 0, maxCooldown: 10000, icon: 'üíö', unlocked: false },
                e: { name: 'Dash', cooldown: 0, maxCooldown: 3000, icon: 'üí®', unlocked: true },
                r: { name: 'Ultimate', cooldown: 0, maxCooldown: 60000, icon: 'üíÄ', unlocked: false }
            },
            quests: [
                { id: 1, name: 'Find the Lost Artifact', completed: false, objectives: ['Search the ruins', 'Find the artifact', 'Return to town'] },
                { id: 2, name: 'Defeat the Shadow Boss', completed: false, objectives: ['Locate the boss', 'Defeat the boss', 'Collect reward'] },
                { id: 3, name: 'Build a Base', completed: false, objectives: ['Gather resources', 'Build walls', 'Build a workshop'] }
            ],
            npcs: [],
            enemies: [],
            vehicles: [],
            particles: [],
            structures: [],
            companions: [],
            soundEnabled: true,
            currentDialogue: null,
            clock: new THREE.Clock(),
            raycaster: new THREE.Raycaster(),
            mouse: new THREE.Vector3(),
            audioListener: null,
            sounds: {},
            minimapCtx: null,
            gameMode: 'story',
            multiplayer: {
                enabled: false,
                players: [],
                socket: null,
                roomId: null
            },
            weather: {
                current: 'clear',
                intensity: 0,
                particles: []
            },
            timeOfDay: 12, // 24-hour format
            dayNightSpeed: 0.1
        };

        // Loading simulation with more steps
        let loadingProgress = 0;
        const loadingSteps = [
            { progress: 10, text: 'Loading textures...' },
            { progress: 25, text: 'Initializing physics...' },
            { progress: 40, text: 'Creating world...' },
            { progress: 55, text: 'Loading models...' },
            { progress: 70, text: 'Setting up audio...' },
            { progress: 85, text: 'Initializing multiplayer...' },
            { progress: 100, text: 'Ready to play!' }
        ];
        
        let currentStep = 0;
        const loadingInterval = setInterval(() => {
            if (currentStep < loadingSteps.length) {
                const step = loadingSteps[currentStep];
                loadingProgress = step.progress;
                document.getElementById('loadingProgress').style.width = loadingProgress + '%';
                document.getElementById('loadingText').textContent = 'Loading Shadow Legion: Eternal Wars - ' + step.text;
                
                if (loadingProgress >= 100) {
                    clearInterval(loadingInterval);
                    setTimeout(() => {
                        document.getElementById('loadingScreen').style.display = 'none';
                        showGameModeSelection();
                    }, 1000);
                }
                currentStep++;
            }
        }, 500);

        // Show game mode selection
        function showGameModeSelection() {
            document.getElementById('gameModeSelect').style.display = 'block';
        }

        // Start game mode
        function startGameMode(mode) {
            game.gameMode = mode;
            document.getElementById('gameModeSelect').style.display = 'none';
            
            if (mode === 'coop' || mode === 'pvp' || mode === 'battleroyale') {
                initMultiplayer();
            }
            
            initThreeJS();
        }

        // Initialize Three.js with Cannon.js physics
        function initThreeJS() {
            // Scene
            game.scene = new THREE.Scene();
            game.scene.fog = new THREE.FogExp2(0x000000, 0.01);

            // Camera
            game.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            game.camera.position.set(0, 2, 0);

            // Renderer
            game.renderer = new THREE.WebGLRenderer({ antialias: true });
            game.renderer.setSize(window.innerWidth, window.innerHeight);
            game.renderer.shadowMap.enabled = true;
            game.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            game.renderer.toneMapping = THREE.ACESFilmicToneMapping;
            game.renderer.toneMappingExposure = 1.0;
            document.getElementById('gameCanvas').appendChild(game.renderer.domElement);

            // Physics World
            game.world = new CANNON.World();
            game.world.gravity.set(0, -9.82, 0);
            game.world.broadphase = new CANNON.NaiveBroadphase();
            game.world.solver.iterations = 10;

            // Audio Listener
            game.audioListener = new THREE.AudioListener();
            game.camera.add(game.audioListener);

            // Enhanced Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
            game.scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            game.scene.add(directionalLight);

            // Hemisphere lighting
            const hemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0x545454, 0.5);
            game.scene.add(hemisphereLight);

            // Skybox
            const skyboxGeometry = new THREE.BoxGeometry(1000, 1000, 1000);
            const skyboxMaterials = [
                new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('https://picsum.photos/seed/skybox-right/1024/1024.jpg'), side: THREE.BackSide }),
                new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('https://picsum.photos/seed/skybox-left/1024/1024.jpg'), side: THREE.BackSide }),
                new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('https://picsum.photos/seed/skybox-top/1024/1024.jpg'), side: THREE.BackSide }),
                new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('https://picsum.photos/seed/skybox-bottom/1024/1024.jpg'), side: THREE.BackSide }),
                new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('https://picsum.photos/seed/skybox-front/1024/1024.jpg'), side: THREE.BackSide }),
                new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('https://picsum.photos/seed/skybox-back/1024/1024.jpg'), side: THREE.BackSide })
            ];
            const skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterials);
            game.scene.add(skybox);

            // Create enhanced world
            createEnhancedWorld();
            createPlayer();
            createNPCs();
            createEnemies();
            createVehicles();
            createCompanions();
            initMinimap();
            initSounds();
            initWeather();
            loadSaveData();

            // Start game loop
            animate();
        }

        // Create enhanced world with physics
        function createEnhancedWorld() {
            // Ground with physics
            const groundGeometry = new THREE.PlaneGeometry(1000, 1000, 50, 50);
            const groundTexture = new THREE.TextureLoader().load('https://picsum.photos/seed/ground-texture/1024/1024.jpg');
            groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
            groundTexture.repeat.set(50, 50);
            const groundMaterial = new THREE.MeshLambertMaterial({ map: groundTexture });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            game.scene.add(ground);

            // Physics ground
            const groundShape = new CANNON.Plane();
            const groundBody = new CANNON.Body({ mass: 0 });
            groundBody.addShape(groundShape);
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            game.world.add(groundBody);

            // Enhanced buildings with physics
            for (let i = 0; i < 20; i++) {
                const buildingGroup = new THREE.Group();
                
                const buildingGeometry = new THREE.BoxGeometry(
                    Math.random() * 20 + 10,
                    Math.random() * 30 + 10,
                    Math.random() * 20 + 10
                );
                const buildingMaterial = new THREE.MeshLambertMaterial({ 
                    color: new THREE.Color().setHSL(Math.random(), 0.5, 0.3) 
                });
                const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                building.castShadow = true;
                building.receiveShadow = true;
                buildingGroup.add(building);

                // Physics body for building
                const buildingShape = new CANNON.Box(new CANNON.Vec3(
                    buildingGeometry.parameters.width / 2,
                    buildingGeometry.parameters.height / 2,
                    buildingGeometry.parameters.depth / 2
                ));
                const buildingBody = new CANNON.Body({ mass: 0 });
                buildingBody.addShape(buildingShape);
                buildingGroup.userData.physicsBody = buildingBody;
                game.world.add(buildingBody);

                // Add windows
                const windowGeometry = new THREE.PlaneGeometry(2, 2);
                const windowMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00,
                    emissive: 0xffff00,
                    emissiveIntensity: 0.5
                });
                
                for (let j = 0; j < 10; j++) {
                    const window = new THREE.Mesh(windowGeometry, windowMaterial);
                    window.position.set(
                        (Math.random() - 0.5) * buildingGeometry.parameters.width * 0.8,
                        (Math.random() - 0.5) * buildingGeometry.parameters.height * 0.8,
                        buildingGeometry.parameters.depth / 2 + 0.1
                    );
                    buildingGroup.add(window);
                }

                const posX = (Math.random() - 0.5) * 200;
                const posY = buildingGeometry.parameters.height / 2;
                const posZ = (Math.random() - 0.5) * 200;
                
                buildingGroup.position.set(posX, posY, posZ);
                buildingBody.position.set(posX, posY, posZ);
                
                game.scene.add(buildingGroup);
            }

            // Enhanced trees
            for (let i = 0; i < 50; i++) {
                const treeGroup = new THREE.Group();
                
                const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.7, 5);
                const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                
                const leavesGeometry = new THREE.SphereGeometry(3);
                const leavesMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                leaves.position.y = 4;
                
                treeGroup.add(trunk);
                treeGroup.add(leaves);
                treeGroup.position.set(
                    (Math.random() - 0.5) * 300,
                    2.5,
                    (Math.random() - 0.5) * 300
                );
                treeGroup.castShadow = true;
                game.scene.add(treeGroup);
            }

            // Add decorative elements with physics
            for (let i = 0; i < 30; i++) {
                const rockGeometry = new THREE.DodecahedronGeometry(Math.random() * 2 + 0.5);
                const rockMaterial = new THREE.MeshLambertMaterial({ color: 0x696969 });
                const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                
                const posX = (Math.random() - 0.5) * 400;
                const posY = 0.5;
                const posZ = (Math.random() - 0.5) * 400;
                
                rock.position.set(posX, posY, posZ);
                rock.castShadow = true;
                rock.receiveShadow = true;
                game.scene.add(rock);

                // Physics for rocks
                const rockShape = new CANNON.Sphere(rockGeometry.parameters.radius);
                const rockBody = new CANNON.Body({ mass: 1 });
                rockBody.addShape(rockShape);
                rockBody.position.set(posX, posY, posZ);
                game.world.add(rockBody);
                rock.userData.physicsBody = rockBody;
            }
        }

        // Create player with physics
        function createPlayer() {
            const playerGeometry = new THREE.CapsuleGeometry(0.5, 1.8, 4, 8);
            const playerMaterial = new THREE.MeshLambertMaterial({ color: 0x0066cc });
            game.player.mesh = new THREE.Mesh(playerGeometry, playerMaterial);
            game.player.mesh.position.set(0, 1, 0);
            game.player.mesh.castShadow = true;
            game.scene.add(game.player.mesh);

            // Physics body for player
            const playerShape = new CANNON.Sphere(0.5);
            game.player.body = new CANNON.Body({ mass: 5 });
            game.player.body.addShape(playerShape);
            game.player.body.position.set(0, 1, 0);
            game.player.body.linearDamping = 0.4;
            game.world.add(game.player.body);
        }

        // Create enhanced NPCs
        function createNPCs() {
            const npcData = [
                { name: 'Old Man', position: [10, 1, 10], color: 0x8B4513, dialogue: 'Greetings, traveler! The ruins to the north hold many secrets.' },
                { name: 'Guard', position: [20, 1, 20], color: 0x696969, dialogue: 'Halt! State your business in this town.' },
                { name: 'Merchant', position: [-15, 1, -15], color: 0x4B0082, dialogue: 'Welcome to my shop! I have many wares for sale.' },
                { name: 'Blacksmith', position: [30, 1, 30], color: 0x8B0000, dialogue: 'Need your weapon repaired? I can help with that.' }
            ];

            npcData.forEach(data => {
                const npcGroup = new THREE.Group();
                
                const npcGeometry = new THREE.CapsuleGeometry(0.5, 1.8, 4, 8);
                const npcMaterial = new THREE.MeshLambertMaterial({ color: data.color });
                const npc = new THREE.Mesh(npcGeometry, npcMaterial);
                npc.castShadow = true;
                npcGroup.add(npc);

                // Add name tag
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                context.fillStyle = 'white';
                context.font = '24px Arial';
                context.textAlign = 'center';
                context.fillText(data.name, 128, 40);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.y = 2;
                sprite.scale.set(4, 1, 1);
                npcGroup.add(sprite);
                
                npcGroup.position.set(...data.position);
                npcGroup.userData = { 
                    name: data.name, 
                    type: 'npc',
                    dialogue: data.dialogue,
                    quests: data.quests || []
                };
                game.scene.add(npcGroup);
                game.npcs.push(npcGroup);
            });
        }

        // Create enhanced enemies with AI
        function createEnemies() {
            const enemyData = [
                { name: 'Shadow Warrior', position: [15, 1, 15], color: 0x4B0082, health: 100, damage: 10, speed: 3 },
                { name: 'Dark Archer', position: [25, 1, 25], color: 0x800080, health: 75, damage: 15, speed: 4 },
                { name: 'Shadow Beast', position: [-20, 1, -20], color: 0x8B0000, health: 150, damage: 20, speed: 2 },
                { name: 'Dark Mage', position: [35, 1, 35], color: 0x4B0082, health: 80, damage: 25, speed: 2.5 },
                { name: 'Shadow Assassin', position: [-30, 1, -30], color: 0x2F4F4F, health: 90, damage: 30, speed: 5 }
            ];

            enemyData.forEach(data => {
                const enemyGroup = new THREE.Group();
                
                const enemyGeometry = new THREE.CapsuleGeometry(0.5, 1.8, 4, 8);
                const enemyMaterial = new THREE.MeshLambertMaterial({ color: data.color });
                const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
                enemy.castShadow = true;
                enemyGroup.add(enemy);

                // Add health bar
                const healthBarGeometry = new THREE.PlaneGeometry(2, 0.2);
                const healthBarMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                const healthBar = new THREE.Mesh(healthBarGeometry, healthBarMaterial);
                healthBar.position.y = 2.5;
                enemyGroup.add(healthBar);
                
                enemyGroup.position.set(...data.position);
                enemyGroup.userData = { 
                    name: data.name, 
                    type: 'enemy',
                    health: data.health,
                    maxHealth: data.health,
                    damage: data.damage,
                    speed: data.speed,
                    healthBar: healthBar,
                    lastAttack: 0,
                    state: 'patrol',
                    patrolTarget: new THREE.Vector3(
                        data.position[0] + (Math.random() - 0.5) * 20,
                        1,
                        data.position[2] + (Math.random() - 0.5) * 20
                    ),
                    abilities: data.abilities || []
                };
                game.scene.add(enemyGroup);
                game.enemies.push(enemyGroup);
            });
        }

        // Create enhanced vehicles
        function createVehicles() {
            const vehicleData = [
                { name: 'Motorcycle', position: [5, 0.5, 5], color: 0xFF0000, speed: 150 },
                { name: 'Car', position: [-10, 0.5, -10], color: 0x0000FF, speed: 100 },
                { name: 'Truck', position: [40, 0.5, 40], color: 0x008000, speed: 80 }
            ];

            vehicleData.forEach(data => {
                const vehicleGroup = new THREE.Group();
                
                if (data.name === 'Motorcycle') {
                    // Motorcycle
                    const bodyGeometry = new THREE.BoxGeometry(2, 0.5, 1);
                    const bodyMaterial = new THREE.MeshLambertMaterial({ color: data.color });
                    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                    body.position.y = 0.5;
                    body.castShadow = true;
                    
                    const wheelGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.2);
                    const wheelMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
                    
                    const wheel1 = new THREE.Mesh(wheelGeometry, wheelMaterial);
                    wheel1.rotation.z = Math.PI / 2;
                    wheel1.position.set(-0.8, 0.3, 0.5);
                    
                    const wheel2 = new THREE.Mesh(wheelGeometry, wheelMaterial);
                    wheel2.rotation.z = Math.PI / 2;
                    wheel2.position.set(0.8, 0.3, 0.5);
                    
                    vehicleGroup.add(body);
                    vehicleGroup.add(wheel1);
                    vehicleGroup.add(wheel2);
                } else if (data.name === 'Car') {
                    // Car
                    const bodyGeometry = new THREE.BoxGeometry(4, 1.5, 2);
                    const bodyMaterial = new THREE.MeshLambertMaterial({ color: data.color });
                    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                    body.position.y = 0.75;
                    body.castShadow = true;
                    
                    const wheelGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.3);
                    const wheelMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
                    
                    const wheels = [];
                    const wheelPositions = [
                        [-1.5, 0.4, 1], [1.5, 0.4, 1],
                        [-1.5, 0.4, -1], [1.5, 0.4, -1]
                    ];
                    
                    wheelPositions.forEach(pos => {
                        const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                        wheel.rotation.z = Math.PI / 2;
                        wheel.position.set(...pos);
                        wheels.push(wheel);
                        vehicleGroup.add(wheel);
                    });
                    
                    vehicleGroup.add(body);
                } else {
                    // Truck
                    const bodyGeometry = new THREE.BoxGeometry(6, 2, 2.5);
                    const bodyMaterial = new THREE.MeshLambertMaterial({ color: data.color });
                    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                    body.position.y = 1;
                    body.castShadow = true;
                    
                    const wheelGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.4);
                    const wheelMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
                    
                    const wheels = [];
                    const wheelPositions = [
                        [-2, 0.5, 1.2], [2, 0.5, 1.2],
                        [-2, 0.5, -1.2], [2, 0.5, -1.2]
                    ];
                    
                    wheelPositions.forEach(pos => {
                        const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                        wheel.rotation.z = Math.PI / 2;
                        wheel.position.set(...pos);
                        wheels.push(wheel);
                        vehicleGroup.add(wheel);
                    });
                    
                    vehicleGroup.add(body);
                }
                
                vehicleGroup.position.set(...data.position);
                vehicleGroup.userData = { 
                    name: data.name, 
                    type: 'vehicle',
                    speed: 0,
                    maxSpeed: data.speed
                };
                
                game.scene.add(vehicleGroup);
                game.vehicles.push(vehicleGroup);
            });
        }

        // Create companions
        function createCompanions() {
            const companionData = [
                { name: 'Wolf', position: [5, 1, 5], color: 0x8B4513, health: 80, damage: 15 },
                { name: 'Eagle', position: [-5, 3, -5], color: 0x4169E1, health: 50, damage: 10 }
            ];

            companionData.forEach(data => {
                const companionGroup = new THREE.Group();
                
                let companionGeometry;
                if (data.name === 'Wolf') {
                    companionGeometry = new THREE.BoxGeometry(1, 0.8, 2);
                } else {
                    companionGeometry = new THREE.SphereGeometry(0.5);
                }
                
                const companionMaterial = new THREE.MeshLambertMaterial({ color: data.color });
                const companion = new THREE.Mesh(companionGeometry, companionMaterial);
                companion.castShadow = true;
                companionGroup.add(companion);
                
                companionGroup.position.set(...data.position);
                companionGroup.userData = { 
                    name: data.name, 
                    type: 'companion',
                    health: data.health,
                    maxHealth: data.health,
                    damage: data.damage,
                    owner: null
                };
                
                game.scene.add(companionGroup);
                game.companions.push(companionGroup);
            });
        }

        // Initialize multiplayer
        function initMultiplayer() {
            // Simulate multiplayer connection
            game.multiplayer.enabled = true;
            document.getElementById('multiplayerHUD').style.display = 'block';
            
            // Add simulated players
            const playerNames = ['Player2', 'Player3', 'Player4'];
            playerNames.forEach(name => {
                game.multiplayer.players.push({
                    name: name,
                    health: 100,
                    status: 'online'
                });
            });
            
            updateMultiplayerHUD();
        }

        // Update multiplayer HUD
        function updateMultiplayerHUD() {
            const playerList = document.getElementById('playerList');
            playerList.innerHTML = '';
            
            game.multiplayer.players.forEach(player => {
                const playerInfo = document.createElement('div');
                playerInfo.className = 'player-info';
                playerInfo.innerHTML = `
                    <div class="player-status"></div>
                    <span>${player.name}</span>
                `;
                playerList.appendChild(playerInfo);
            });
        }

        // Initialize weather system
        function initWeather() {
            // Start with clear weather
            changeWeather('clear');
            
            // Change weather periodically
            setInterval(() => {
                const weatherTypes = ['clear', 'rain', 'fog', 'storm'];
                const randomWeather = weatherTypes[Math.floor(Math.random() * weatherTypes.length)];
                changeWeather(randomWeather);
            }, 30000);
        }

        // Change weather
        function changeWeather(type) {
            game.weather.current = type;
            const weatherOverlay = document.getElementById('weatherOverlay');
            weatherOverlay.innerHTML = '';
            
            switch(type) {
                case 'rain':
                    for (let i = 0; i < 100; i++) {
                        const rainDrop = document.createElement('div');
                        rainDrop.className = 'rain-drop';
                        rainDrop.style.left = Math.random() * 100 + '%';
                        rainDrop.style.animationDuration = Math.random() * 1 + 0.5 + 's';
                        rainDrop.style.opacity = Math.random() * 0.5 + 0.3;
                        weatherOverlay.appendChild(rainDrop);
                    }
                    break;
                case 'fog':
                    game.scene.fog.density = 0.05;
                    break;
                case 'storm':
                    game.scene.fog.density = 0.1;
                    // Add lightning effect
                    setInterval(() => {
                        if (Math.random() < 0.1) {
                            game.scene.fog.color.setHex(0xffffff);
                            setTimeout(() => {
                                game.scene.fog.color.setHex(0x000000);
                            }, 100);
                        }
                    }, 5000);
                    break;
                default:
                    game.scene.fog.density = 0.01;
            }
        }

        // Initialize minimap
        function initMinimap() {
            const minimapCanvas = document.getElementById('minimapCanvas');
            minimapCanvas.width = 200;
            minimapCanvas.height = 200;
            game.minimapCtx = minimapCanvas.getContext('2d');
        }

        // Initialize sounds
        function initSounds() {
            // Create audio elements
            const soundFiles = ['shoot', 'reload', 'footstep', 'engine', 'door', 'pickup', 'hit'];
            soundFiles.forEach(sound => {
                game.sounds[sound] = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIG2m98OScTgwOUarm7blmFgU7k9n1unEiBC13yO/eizEIHWq+8+OWT');
            });
        }

        // Load save data
        function loadSaveData() {
            const savedData = localStorage.getItem('shadowLegionSave');
            if (savedData) {
                const data = JSON.parse(savedData);
                game.player.level = data.level || 1;
                game.player.xp = data.xp || 0;
                game.player.skillPoints = data.skillPoints || 0;
                game.player.skills = data.skills || game.player.skills;
                game.player.base.resources = data.baseResources || game.player.base.resources;
                
                updateLevelInfo();
                updateSkillPoints();
            }
        }

        // Enhanced input handling
        document.addEventListener('keydown', (e) => {
            game.keys[e.key.toLowerCase()] = true;
            
            if (e.key === ' ') shoot();
            if (e.key === 'r') reloadWeapon();
            if (e.key === 'i') openInventory();
            if (e.key === 'm') openMap();
            if (e.key === 'f') interact();
            if (e.key === 'Enter' && game.player.inVehicle) exitVehicle();
            if (e.key === 'Tab') {
                e.preventDefault();
                toggleWeaponWheel();
            }
            if (e.key >= '1' && e.key <= '4') {
                game.player.currentWeapon = parseInt(e.key) - 1;
                updateWeaponInfo();
            }
            if (e.key === 'k') openSkillTree();
            if (e.key === 'c') openCrafting();
            if (e.key === 'b') openBuildMenu();
            if (e.key === 'Escape') openSaveLoadMenu();
        });

        document.addEventListener('keyup', (e) => {
            game.keys[e.key.toLowerCase()] = false;
        });

        // Mouse look with sensitivity
        document.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement === game.renderer.domElement) {
                const sensitivity = 0.002;
                game.player.yaw -= e.movementX * sensitivity;
                game.player.pitch -= e.movementY * sensitivity;
                game.player.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, game.player.pitch));
            }
        });

        // Click to lock pointer
        game.renderer.domElement.addEventListener('click', () => {
            game.renderer.domElement.requestPointerLock();
        });

        // Enhanced shooting with critical hits
        function shoot() {
            const weapon = game.player.weapons[game.player.currentWeapon];
            const now = Date.now();
            
            if (game.player.isReloading) return;
            if (now - game.player.lastShot < weapon.fireRate) return;
            if (weapon.ammo <= 0) {
                reloadWeapon();
                return;
            }
            
            weapon.ammo--;
            game.player.lastShot = now;
            updateAmmo();
            playSound('shoot');
            
            // Add recoil
            game.player.pitch += (Math.random() - 0.5) * 0.1;
            game.player.yaw += (Math.random() - 0.5) * 0.1;
            
            // Create muzzle flash
            createMuzzleFlash();
            
            // Raycast for shooting
            const direction = new THREE.Vector3();
            game.camera.getWorldDirection(direction);
            
            // Add bullet spread
            const spread = 0.1;
            direction.x += (Math.random() - 0.5) * spread;
            direction.y += (Math.random() - 0.5) * spread;
            direction.z += (Math.random() - 0.5) * spread;
            direction.normalize();
            
            game.raycaster.set(game.camera.position, direction);
            const intersects = game.raycaster.intersectObjects(game.scene.children, true);
            
            if (intersects.length > 0) {
                const hit = intersects[0];
                if (hit.object.parent && hit.object.parent.userData.type === 'enemy') {
                    const enemy = hit.object.parent;
                    let damage = weapon.damage;
                    
                    // Apply skill bonuses
                    damage += game.player.skills.damage * 5;
                    
                    // Critical hit chance
                    if (Math.random() < (0.1 + game.player.skills.critical * 0.1)) {
                        damage *= 2;
                        console.log('CRITICAL HIT!');
                    }
                    
                    enemy.userData.health -= damage;
                    updateEnemyHealth(enemy);
                    showDamageNumber(hit.point, damage);
                    
                    // Gain XP
                    gainXP(10);
                    
                    if (enemy.userData.health <= 0) {
                        createExplosion(enemy.position);
                        game.scene.remove(enemy);
                        game.enemies = game.enemies.filter(e => e !== enemy);
                        gainXP(50);
                        console.log(`${enemy.userData.name} defeated!`);
                    }
                }
                
                // Create impact effect
                createImpactEffect(hit.point, hit.face.normal);
            }
        }

        // Gain XP and level up
        function gainXP(amount) {
            game.player.xp += amount;
            
            while (game.player.xp >= game.player.xpToNext) {
                game.player.xp -= game.player.xpToNext;
                game.player.level++;
                game.player.skillPoints += 2;
                game.player.maxHealth += 10;
                game.player.health = game.player.maxHealth;
                game.player.xpToNext = game.player.level * 100;
                
                console.log(`LEVEL UP! Now level ${game.player.level}`);
                updateLevelInfo();
                updateSkillPoints();
                updateHealth();
            }
            
            updateLevelInfo();
        }

        // Reload weapon
        function reloadWeapon() {
            const weapon = game.player.weapons[game.player.currentWeapon];
            if (game.player.isReloading || weapon.ammo === weapon.maxAmmo) return;
            
            game.player.isReloading = true;
            playSound('reload');
            
            setTimeout(() => {
                weapon.ammo = weapon.maxAmmo;
                game.player.isReloading = false;
                updateAmmo();
            }, weapon.reloadTime);
        }

        // Enhanced movement with physics
        function updateMovement(deltaTime) {
            const speed = game.player.inVehicle ? 50 : (game.keys['shift'] ? 10 : 5);
            const direction = new THREE.Vector3();
            
            if (game.keys['w']) direction.z -= 1;
            if (game.keys['s']) direction.z += 1;
            if (game.keys['a']) direction.x -= 1;
            if (game.keys['d']) direction.x += 1;
            
            direction.normalize();
            direction.multiplyScalar(speed * deltaTime);
            
            // Apply rotation
            direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), game.player.yaw);
            
            // Apply physics force
            if (game.player.body) {
                const force = new CANNON.Vec3(direction.x, 0, direction.z);
                force.scale(10, force);
                game.player.body.applyForce(force, game.player.body.position);
                
                // Update mesh position to match physics
                game.player.mesh.position.copy(game.player.body.position);
                game.player.mesh.position.y -= 0.5; // Offset for capsule
            }
            
            // Update camera position
            game.camera.position.copy(game.player.mesh.position);
            game.camera.position.y += 1.8;
            
            // Jumping
            if (game.keys[' '] && game.player.isGrounded && !game.player.isJumping) {
                if (game.player.body) {
                    game.player.body.velocity.y = 8;
                    game.player.isJumping = true;
                    game.player.isGrounded = false;
                }
            }
            
            // Check if grounded
            if (game.player.body) {
                game.player.isGrounded = Math.abs(game.player.body.velocity.y) < 0.1;
                if (game.player.isGrounded) {
                    game.player.isJumping = false;
                }
            }
            
            // Update camera rotation
            game.camera.rotation.order = 'YXZ';
            game.camera.rotation.y = game.player.yaw;
            game.camera.rotation.x = game.player.pitch;
            
            // Stamina with skill bonus
            const staminaDrain = game.keys['shift'] && game.player.stamina > 0 && !game.player.inVehicle ? 
                (20 - game.player.skills.speed * 2) * deltaTime : 0;
            const staminaRegen = game.player.stamina < game.player.maxStamina ? 
                (10 + game.player.skills.speed * 1) * deltaTime : 0;
            
            if (staminaDrain > 0) {
                game.player.stamina -= staminaDrain;
            } else {
                game.player.stamina += staminaRegen;
            }
            updateStamina();
            
            // Footstep sounds
            if ((game.keys['w'] || game.keys['s'] || game.keys['a'] || game.keys['d']) && game.player.isGrounded) {
                if (Math.random() < 0.1) {
                    playSound('footstep');
                }
            }
        }

        // Enhanced enemy AI with formations
        function updateEnemies(deltaTime) {
            game.enemies.forEach(enemy => {
                const distance = enemy.position.distanceTo(game.player.mesh.position);
                const now = Date.now();
                
                // State machine
                if (distance < 20) {
                    enemy.userData.state = 'chase';
                } else if (enemy.userData.state === 'chase' && distance > 30) {
                    enemy.userData.state = 'patrol';
                }
                
                if (enemy.userData.state === 'chase') {
                    // Move towards player
                    const direction = new THREE.Vector3()
                        .subVectors(game.player.mesh.position, enemy.position)
                        .normalize();
                    enemy.position.add(direction.multiplyScalar(enemy.userData.speed * deltaTime));
                    
                    // Attack if close
                    if (distance < 3 && now - enemy.userData.lastAttack > 1000) {
                        takeDamage(enemy.userData.damage);
                        enemy.userData.lastAttack = now;
                    }
                    
                    // Use abilities
                    if (enemy.userData.abilities.length > 0 && Math.random() < 0.01) {
                        const ability = enemy.userData.abilities[Math.floor(Math.random() * enemy.userData.abilities.length)];
                        useEnemyAbility(enemy, ability);
                    }
                } else if (enemy.userData.state === 'patrol') {
                    // Patrol movement
                    const patrolDistance = enemy.position.distanceTo(enemy.userData.patrolTarget);
                    if (patrolDistance < 2) {
                        enemy.userData.patrolTarget = new THREE.Vector3(
                            enemy.position.x + (Math.random() - 0.5) * 20,
                            1,
                            enemy.position.z + (Math.random() - 0.5) * 20
                        );
                    }
                    
                    const direction = new THREE.Vector3()
                        .subVectors(enemy.userData.patrolTarget, enemy.position)
                        .normalize();
                    enemy.position.add(direction.multiplyScalar(1 * deltaTime));
                }
                
                // Face the player when chasing
                if (enemy.userData.state === 'chase') {
                    enemy.lookAt(game.player.mesh.position);
                }
            });
        }

        // Use enemy ability
        function useEnemyAbility(enemy, ability) {
            switch(ability) {
                case 'teleport':
                    // Teleport near player
                    const offset = new THREE.Vector3(
                        (Math.random() - 0.5) * 10,
                        0,
                        (Math.random() - 0.5) * 10
                    );
                    enemy.position.copy(game.player.mesh.position).add(offset);
                    break;
                case 'summon':
                    // Summon another enemy
                    console.log('Enemy summons reinforcements!');
                    break;
            }
        }

        // Update companions
        function updateCompanions(deltaTime) {
            if (game.player.companion) {
                const companion = game.player.companion;
                const distance = companion.position.distanceTo(game.player.mesh.position);
                
                // Follow player
                if (distance > 5) {
                    const direction = new THREE.Vector3()
                        .subVectors(game.player.mesh.position, companion.position)
                        .normalize();
                    companion.position.add(direction.multiplyScalar(3 * deltaTime));
                }
                
                // Attack nearby enemies
                game.enemies.forEach(enemy => {
                    const enemyDistance = companion.position.distanceTo(enemy.position);
                    if (enemyDistance < 3) {
                        enemy.userData.health -= companion.userData.damage * deltaTime;
                        updateEnemyHealth(enemy);
                    }
                });
            }
        }

        // Update day/night cycle
        function updateDayNightCycle(deltaTime) {
            game.timeOfDay += game.dayNightSpeed * deltaTime;
            if (game.timeOfDay >= 24) {
                game.timeOfDay = 0;
            }
            
            // Update lighting based on time
            const hour = game.timeOfDay;
            let lightIntensity = 1;
            
            if (hour >= 6 && hour <= 18) {
                // Day time
                lightIntensity = 1;
            } else if (hour > 18 && hour <= 20) {
                // Sunset
                lightIntensity = 0.5;
            } else if (hour > 20 || hour < 6) {
                // Night
                lightIntensity = 0.2;
            } else {
                // Sunrise
                lightIntensity = 0.5;
            }
            
            game.scene.children.forEach(child => {
                if (child.type === 'DirectionalLight') {
                    child.intensity = lightIntensity;
                }
            });
        }

        // Particle effects
        function createMuzzleFlash() {
            const flashGeometry = new THREE.PlaneGeometry(0.5, 0.5);
            const flashMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffff00,
                transparent: true,
                opacity: 0.8
            });
            const flash = new THREE.Mesh(flashGeometry, flashMaterial);
            
            const direction = new THREE.Vector3();
            game.camera.getWorldDirection(direction);
            flash.position.copy(game.camera.position).add(direction.multiplyScalar(1));
            flash.lookAt(flash.position.clone().add(direction));
            
            game.scene.add(flash);
            
            setTimeout(() => {
                game.scene.remove(flash);
            }, 50);
        }

        function createImpactEffect(position, normal) {
            const particleCount = 10;
            const particles = new THREE.Group();
            
            for (let i = 0; i < particleCount; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.05);
                const particleMaterial = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                particle.position.copy(position);
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.2,
                    (Math.random() - 0.5) * 0.2,
                    (Math.random() - 0.5) * 0.2
                );
                
                particles.add(particle);
            }
            
            game.scene.add(particles);
            game.particles.push(particles);
        }

        function createExplosion(position) {
            const particleCount = 50;
            const particles = new THREE.Group();
            
            for (let i = 0; i < particleCount; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.1);
                const particleMaterial = new THREE.MeshBasicMaterial({ 
                    color: new THREE.Color().setHSL(Math.random() * 0.1, 1, 0.5)
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                particle.position.copy(position);
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.5,
                    Math.random() * 0.5,
                    (Math.random() - 0.5) * 0.5
                );
                
                particles.add(particle);
            }
            
            game.scene.add(particles);
            game.particles.push(particles);
        }

        function updateParticles(deltaTime) {
            game.particles.forEach((particles, index) => {
                let allDead = true;
                
                particles.children.forEach(particle => {
                    particle.position.add(particle.velocity);
                    particle.velocity.y -= 0.01;
                    particle.material.opacity -= 0.02;
                    
                    if (particle.material.opacity > 0) {
                        allDead = false;
                    }
                });
                
                if (allDead) {
                    game.scene.remove(particles);
                    game.particles.splice(index, 1);
                }
            });
        }

        // Update minimap
        function updateMinimap() {
            if (!game.minimapCtx) return;
            
            const ctx = game.minimapCtx;
            const scale = 0.5;
            
            // Clear minimap
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, 200, 200);
            
            // Draw player
            ctx.fillStyle = '#00ff00';
            ctx.beginPath();
            ctx.arc(100 + game.player.mesh.position.x * scale, 100 + game.player.mesh.position.z * scale, 3, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw enemies
            ctx.fillStyle = '#ff0000';
            game.enemies.forEach(enemy => {
                ctx.beginPath();
                ctx.arc(100 + enemy.position.x * scale, 100 + enemy.position.z * scale, 2, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Draw NPCs
            ctx.fillStyle = '#ffff00';
            game.npcs.forEach(npc => {
                ctx.beginPath();
                ctx.arc(100 + npc.position.x * scale, 100 + npc.position.z * scale, 2, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Draw companions
            ctx.fillStyle = '#00ffff';
            game.companions.forEach(companion => {
                ctx.beginPath();
                ctx.arc(100 + companion.position.x * scale, 100 + companion.position.z * scale, 2, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // UI Functions
        function showDamageNumber(position, damage) {
            const damageElement = document.createElement('div');
            damageElement.className = 'damage-number';
            damageElement.textContent = `-${damage}`;
            
            // Convert 3D position to screen position
            const vector = position.clone();
            vector.project(game.camera);
            
            const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
            
            damageElement.style.left = x + 'px';
            damageElement.style.top = y + 'px';
            
            document.getElementById('ui').appendChild(damageElement);
            
            setTimeout(() => {
                damageElement.remove();
            }, 1000);
        }

        function updateEnemyHealth(enemy) {
            const healthPercent = enemy.userData.health / enemy.userData.maxHealth;
            enemy.userData.healthBar.scale.x = healthPercent;
            enemy.userData.healthBar.material.color.setHSL(healthPercent * 0.3, 1, 0.5);
        }

        function updateWeaponInfo() {
            const weapon = game.player.weapons[game.player.currentWeapon];
            document.getElementById('weaponInfo').textContent = `Weapon: ${weapon.name} (Lvl ${weapon.level})`;
        }

        function updateLevelInfo() {
            document.getElementById('levelInfo').textContent = 
                `Level: ${game.player.level} | XP: ${game.player.xp}/${game.player.xpToNext}`;
        }

        function updateSkillPoints() {
            document.getElementById('skillPoints').textContent = game.player.skillPoints;
        }

        function toggleWeaponWheel() {
            const wheel = document.getElementById('weaponWheel');
            wheel.style.display = wheel.style.display === 'none' ? 'block' : 'none';
            
            // Update selection
            document.querySelectorAll('.weapon-slot').forEach((slot, index) => {
                slot.classList.toggle('selected', index === game.player.currentWeapon);
            });
        }

        // Inventory management
        let currentInventoryTab = 'items';
        function switchInventoryTab(tab) {
            currentInventoryTab = tab;
            document.querySelectorAll('.inventory-tab').forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');
            renderInventory();
        }

        function openInventory() {
            document.getElementById('inventory').style.display = 'block';
            renderInventory();
        }
        function closeInventory() {
            document.getElementById('inventory').style.display = 'none';
        }
        function renderInventory() {
            const grid = document.getElementById('inventoryGrid');
            grid.innerHTML = '';
            
            const filteredItems = game.player.inventory.filter(item => {
                if (currentInventoryTab === 'items') return item.type === 'consumable' || item.type === 'quest';
                if (currentInventoryTab === 'weapons') return item.type === 'weapon';
                if (currentInventoryTab === 'armor') return item.type === 'armor';
                if (currentInventoryTab === 'crafting') return item.type === 'crafting';
                return true;
            });
            
            filteredItems.forEach((item, index) => {
                const slot = document.createElement('div');
                slot.className = 'inventorySlot';
                if (item.equipped) slot.classList.add('equipped');
                slot.innerHTML = `
                    ${item.icon}
                    ${item.quantity > 1 ? `<span style="position: absolute; bottom: 2px; right: 2px; font-size: 12px;">${item.quantity}</span>` : ''}
                `;
                slot.onclick = () => useItem(item);
                grid.appendChild(slot);
            });
        }
        function useItem(item) {
            if (item.type === 'consumable') {
                console.log(`Used ${item.name}`);
                if (item.name === 'Health Potion') {
                    game.player.health = Math.min(game.player.maxHealth, game.player.health + 30);
                    updateHealth();
                }
                if (item.quantity > 1) {
                    item.quantity--;
                } else {
                    game.player.inventory = game.player.inventory.filter(i => i.id !== item.id);
                }
                renderInventory();
            } else if (item.type === 'weapon') {
                // Equip weapon
                game.player.inventory.forEach(i => i.equipped = false);
                item.equipped = true;
                renderInventory();
            }
        }

        // Skill tree
        function openSkillTree() {
            document.getElementById('skillTree').style.display = 'block';
            updateSkillTree();
        }
        function closeSkillTree() {
            document.getElementById('skillTree').style.display = 'none';
        }
        function updateSkillTree() {
            document.querySelectorAll('.skill-node').forEach(node => {
                const skill = node.dataset.skill;
                const cost = parseInt(node.dataset.cost);
                const level = game.player.skills[skill];
                
                node.classList.toggle('unlocked', level > 0);
                node.classList.toggle('available', game.player.skillPoints >= cost && level === 0);
                
                node.onclick = () => {
                    if (game.player.skillPoints >= cost && level === 0) {
                        game.player.skillPoints -= cost;
                        game.player.skills[skill] = 1;
                        updateSkillPoints();
                        updateSkillTree();
                        
                        // Unlock abilities
                        if (skill === 'fireball') game.abilities.q.unlocked = true;
                        if (skill === 'heal') game.abilities.w.unlocked = true;
                        if (skill === 'teleport') game.abilities.r.unlocked = true;
                        if (skill === 'invisibility') game.abilities.e.unlocked = true;
                        
                        console.log(`Learned skill: ${skill}`);
                    }
                };
            });
        }

        // Crafting system
        function openCrafting() {
            document.getElementById('crafting').style.display = 'block';
        }
        function closeCrafting() {
            document.getElementById('crafting').style.display = 'none';
        }
        function craftItem(itemType) {
            const recipes = {
                health_potion: { herbs: 2, bottle: 1 },
                ammo: { metal: 3, gunpowder: 2 },
                weapon_upgrade: { metal: 5, crystal: 1 },
                armor: { leather: 3, metal: 2 }
            };
            
            const recipe = recipes[itemType];
            if (!recipe) return;
            
            // Check if player has materials
            let canCraft = true;
            for (const [material, amount] of Object.entries(recipe)) {
                const item = game.player.inventory.find(i => i.name.toLowerCase().includes(material));
                if (!item || item.quantity < amount) {
                    canCraft = false;
                    break;
                }
            }
            
            if (canCraft) {
                // Consume materials
                for (const [material, amount] of Object.entries(recipe)) {
                    const item = game.player.inventory.find(i => i.name.toLowerCase().includes(material));
                    item.quantity -= amount;
                    if (item.quantity === 0) {
                        game.player.inventory = game.player.inventory.filter(i => i !== item);
                    }
                }
                
                // Add crafted item
                const craftedItems = {
                    health_potion: { name: 'Health Potion', type: 'consumable', icon: 'üß™', quantity: 1 },
                    ammo: { name: 'Ammo Box', type: 'consumable', icon: 'üì¶', quantity: 1 },
                    weapon_upgrade: { name: 'Weapon Upgrade Kit', type: 'upgrade', icon: '‚¨ÜÔ∏è', quantity: 1 },
                    armor: { name: 'Armor Piece', type: 'armor', icon: 'üõ°Ô∏è', quantity: 1 }
                };
                
                game.player.inventory.push(craftedItems[itemType]);
                console.log(`Crafted ${itemType}!`);
                renderInventory();
            } else {
                console.log('Not enough materials!');
            }
        }

        // Base building
        function openBuildMenu() {
            document.getElementById('buildMenu').style.display = 'block';
        }
        function closeBuildMenu() {
            document.getElementById('buildMenu').style.display = 'none';
        }
        function buildStructure(type) {
            const costs = {
                wall: { wood: 5 },
                tower: { wood: 10, metal: 5 },
                workshop: { wood: 20, metal: 10 },
                storage: { wood: 15 },
                farm: { seeds: 5, wood: 10 },
                barracks: { wood: 30, metal: 20 }
            };
            
            const cost = costs[type];
            if (!cost) return;
            
            // Check if player has resources
            let canBuild = true;
            for (const [resource, amount] of Object.entries(cost)) {
                if (game.player.base.resources[resource] < amount) {
                    canBuild = false;
                    break;
                }
            }
            
            if (canBuild) {
                // Consume resources
                for (const [resource, amount] of Object.entries(cost)) {
                    game.player.base.resources[resource] -= amount;
                }
                
                // Create structure
                const structureGroup = new THREE.Group();
                let structureGeometry, structureMaterial;
                
                switch(type) {
                    case 'wall':
                        structureGeometry = new THREE.BoxGeometry(4, 3, 0.5);
                        structureMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                        break;
                    case 'tower':
                        structureGeometry = new THREE.CylinderGeometry(2, 3, 8);
                        structureMaterial = new THREE.MeshLambertMaterial({ color: 0x696969 });
                        break;
                    case 'workshop':
                        structureGeometry = new THREE.BoxGeometry(8, 4, 6);
                        structureMaterial = new THREE.MeshLambertMaterial({ color: 0x4B0082 });
                        break;
                    default:
                        structureGeometry = new THREE.BoxGeometry(4, 3, 4);
                        structureMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                }
                
                const structure = new THREE.Mesh(structureGeometry, structureMaterial);
                structure.castShadow = true;
                structureGroup.add(structure);
                
                // Place structure near player
                structureGroup.position.copy(game.player.mesh.position);
                structureGroup.position.add(new THREE.Vector3(5, 0, 0));
                
                structureGroup.userData = { type: 'structure', structureType: type };
                game.scene.add(structureGroup);
                game.structures.push(structureGroup);
                
                console.log(`Built ${type}!`);
            } else {
                console.log('Not enough resources!');
            }
        }

        // Save/Load system
        function openSaveLoadMenu() {
            document.getElementById('saveLoadMenu').style.display = 'block';
            updateSaveSlots();
        }
        function closeSaveLoadMenu() {
            document.getElementById('saveLoadMenu').style.display = 'none';
        }
        function updateSaveSlots() {
            for (let i = 1; i <= 3; i++) {
                const saveData = localStorage.getItem(`shadowLegionSave${i}`);
                const infoElement = document.getElementById(`save${i}-info`);
                if (saveData) {
                    const data = JSON.parse(saveData);
                    infoElement.textContent = `Level ${data.level} - ${new Date(data.timestamp).toLocaleDateString()}`;
                } else {
                    infoElement.textContent = 'Empty';
                }
            }
        }
        function saveGame(slot) {
            const saveData = {
                player: {
                    level: game.player.level,
                    xp: game.player.xp,
                    skillPoints: game.player.skillPoints,
                    skills: game.player.skills,
                    position: {
                        x: game.player.mesh.position.x,
                        y: game.player.mesh.position.y,
                        z: game.player.mesh.position.z
                    },
                    inventory: game.player.inventory,
                    baseResources: game.player.base.resources
                },
                quests: game.quests,
                timestamp: Date.now()
            };
            
            localStorage.setItem(`shadowLegionSave${slot}`, JSON.stringify(saveData));
            console.log(`Game saved to slot ${slot}!`);
            updateSaveSlots();
        }

        // Companion system
        function interact() {
            const nearbyObjects = [...game.npcs, ...game.vehicles, ...game.companions].filter(obj => 
                obj.position.distanceTo(game.player.mesh.position) < 5
            );
            
            if (nearbyObjects.length > 0) {
                const obj = nearbyObjects[0];
                if (obj.userData.type === 'npc') {
                    showDialogue(obj.userData);
                } else if (obj.userData.type === 'vehicle') {
                    enterVehicle(obj);
                } else if (obj.userData.type === 'companion') {
                    if (!game.player.companion) {
                        game.player.companion = obj;
                        obj.userData.owner = game.player;
                        document.getElementById('companionHUD').style.display = 'block';
                        console.log('Companion joined!');
                    }
                }
            }
        }

        function showDialogue(npcData) {
            const dialogueBox = document.getElementById('dialogueBox');
            const dialogueText = document.getElementById('dialogueText');
            const dialogueChoices = document.getElementById('dialogueChoices');
            
            dialogueBox.style.display = 'block';
            dialogueText.textContent = `${npcData.name}: ${npcData.dialogue}`;
            dialogueChoices.innerHTML = '';
            
            const choices = [
                { text: 'Tell me more.', action: () => console.log('More info') },
                { text: 'Do you have any quests?', action: () => giveQuest(npcData) },
                { text: 'Goodbye.', action: () => closeDialogue() }
            ];
            
            choices.forEach(choice => {
                const choiceEl = document.createElement('div');
                choiceEl.className = 'dialogueChoice';
                choiceEl.textContent = choice.text;
                choiceEl.onclick = choice.action;
                dialogueChoices.appendChild(choiceEl);
            });
        }

        function giveQuest(npcData) {
            if (npcData.quests && npcData.quests.length > 0) {
                const quest = npcData.quests[0];
                game.quests.push(quest);
                console.log(`New quest: ${quest.name}`);
                updateQuestLog();
            }
        }

        function updateQuestLog() {
            const questList = document.getElementById('questList');
            questList.innerHTML = '';
            
            game.quests.forEach(quest => {
                const li = document.createElement('li');
                li.dataset.quest = quest.id;
                li.textContent = `[${quest.completed ? 'Completed' : 'Active'}] ${quest.name}`;
                questList.appendChild(li);
            });
        }

        function closeDialogue() {
            document.getElementById('dialogueBox').style.display = 'none';
        }

        function enterVehicle(vehicle) {
            game.player.inVehicle = true;
            game.player.vehicle = vehicle;
            document.getElementById('vehicleHUD').style.display = 'block';
            playSound('engine');
        }

        function exitVehicle() {
            game.player.inVehicle = false;
            game.player.vehicle = null;
            document.getElementById('vehicleHUD').style.display = 'none';
            playSound('door');
        }

        function openMap() {
            document.getElementById('worldMap').style.display = 'block';
        }

        function closeMap() {
            document.getElementById('worldMap').style.display = 'none';
        }

        function fastTravel(location) {
            console.log(`Fast traveling to ${location}`);
            game.player.mesh.position.set(
                Math.random() * 100 - 50,
                1,
                Math.random() * 100 - 50
            );
            closeMap();
        }

        function playSound(soundName) {
            if (!game.soundEnabled || !game.sounds[soundName]) return;
            game.sounds[soundName].currentTime = 0;
            game.sounds[soundName].play().catch(e => console.log('Sound play failed:', e));
        }

        function toggleSound() {
            game.soundEnabled = !game.soundEnabled;
            document.getElementById('soundToggle').textContent = 
                game.soundEnabled ? 'üîä Sound ON' : 'üîá Sound OFF';
        }

        function takeDamage(amount) {
            game.player.health -= amount;
            updateHealth();
            
            // Screen shake effect
            game.camera.rotation.x += (Math.random() - 0.5) * 0.1;
            game.camera.rotation.y += (Math.random() - 0.5) * 0.1;
            
            if (game.player.health <= 0) {
                console.log('You died! Respawning...');
                game.player.health = game.player.maxHealth;
                game.player.mesh.position.set(0, 1, 0);
                if (game.player.body) {
                    game.player.body.position.set(0, 1, 0);
                }
                updateHealth();
            }
        }

        function updateHealth() {
            const percentage = (game.player.health / game.player.maxHealth) * 100;
            document.getElementById('healthFill').style.width = percentage + '%';
        }

        function updateStamina() {
            const percentage = (game.player.stamina / game.player.maxStamina) * 100;
            document.getElementById('staminaFill').style.width = percentage + '%';
        }

        function updateAmmo() {
            const weapon = game.player.weapons[game.player.currentWeapon];
            document.getElementById('ammo').textContent = `Ammo: ${weapon.ammo}/${weapon.maxAmmo}`;
        }

        function updateCompanionHealth() {
            if (game.player.companion) {
                const companion = game.player.companion;
                const healthPercent = companion.userData.health / companion.userData.maxHealth;
                document.getElementById('companionHealthFill').style.width = (healthPercent * 100) + '%';
            }
        }

        // Ultimate game loop
        function animate() {
            requestAnimationFrame(animate);
            
            const deltaTime = game.clock.getDelta();
            
            // Update physics
            game.world.step(1/60, deltaTime, 3);
            
            updateMovement(deltaTime);
            updateEnemies(deltaTime);
            updateCompanions(deltaTime);
            updateParticles(deltaTime);
            updateMinimap();
            updateDayNightCycle(deltaTime);
            updateCompanionHealth();
            
            // Update ability cooldowns
            Object.keys(game.abilities).forEach(key => {
                const ability = game.abilities[key];
                if (ability.cooldown > 0) {
                    ability.cooldown -= deltaTime * 1000;
                    const overlay = document.querySelector(`[data-ability="${key}"] .cooldown-overlay`);
                    if (overlay) {
                        const percent = Math.max(0, ability.cooldown / ability.maxCooldown);
                        overlay.style.height = (percent * 100) + '%';
                    }
                }
            });
            
            // Update vehicle speed
            if (game.player.inVehicle && game.player.vehicle) {
                game.player.vehicle.userData.speed = Math.min(
                    game.player.vehicle.userData.maxSpeed,
                    game.player.vehicle.userData.speed + 50 * deltaTime
                );
                document.getElementById('speed').textContent = Math.floor(game.player.vehicle.userData.speed);
            }
            
            game.renderer.render(game.scene, game.camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            game.camera.aspect = window.innerWidth / window.innerHeight;
            game.camera.updateProjectionMatrix();
            game.renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Auto-save every 30 seconds
        setInterval(() => {
            if (game.gameMode === 'story') {
                saveGame(1);
                console.log('Auto-saved game!');
            }
        }, 30000);

        // Test functions
        setTimeout(() => takeDamage(20), 2000);
        setTimeout(() => {
            const quest = game.quests.find(q => q.id === 1);
            if (quest && !quest.completed) {
                quest.completed = true;
                document.querySelector(`[data-quest="${quest.id}"]`).textContent = `[Completed] ${quest.name}`;
                gainXP(100);
                console.log(`Quest completed: ${quest.name}`);
            }
        }, 5000);
    </script>
</body>
</html>
