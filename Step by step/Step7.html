<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shadow Legion: Eternal Wars - Ultimate Pro Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; color: #fff; font-family: 'Arial', sans-serif; }
        #gameCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100; }
        .ui-element { position: absolute; pointer-events: auto; }
        
        /* Main HUD */
        #healthBar { top: 20px; left: 20px; width: 300px; height: 30px; background: rgba(0,0,0,0.7); border: 2px solid #fff; border-radius: 5px; overflow: hidden; }
        #healthFill { height: 100%; background: linear-gradient(to right, #f00, #ff0); width: 100%; transition: width 0.3s; }
        #staminaBar { top: 60px; left: 20px; width: 300px; height: 20px; background: rgba(0,0,0,0.7); border: 2px solid #fff; border-radius: 5px; overflow: hidden; }
        #staminaFill { height: 100%; background: linear-gradient(to right, #0f0, #0ff); width: 100%; transition: width 0.3s; }
        #ammo { top: 90px; left: 20px; font-size: 20px; text-shadow: 2px 2px #000; }
        #weaponInfo { top: 120px; left: 20px; font-size: 16px; text-shadow: 2px 2px #000; }
        #levelInfo { top: 150px; left: 20px; font-size: 16px; text-shadow: 2px 2px #000; }
        #currency { top: 180px; left: 20px; font-size: 16px; text-shadow: 2px 2px #000; }
        
        /* Abilities */
        #abilities { bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; }
        .ability { width: 60px; height: 60px; background: rgba(0,0,0,0.7); border: 2px solid #fff; border-radius: 10px; display: flex; align-items: center; justify-content: center; font-size: 24px; cursor: pointer; transition: all 0.2s; position: relative; }
        .ability:hover { background: rgba(255,255,255,0.2); transform: scale(1.1); }
        .ability.cooldown { opacity: 0.5; cursor: not-allowed; }
        .cooldown-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); border-radius: 8px; }
        
        /* Minimap */
        #minimap { top: 20px; right: 20px; width: 200px; height: 200px; background: rgba(0,0,0,0.7); border: 2px solid #fff; border-radius: 10px; overflow: hidden; }
        #minimapCanvas { width: 100%; height: 100%; }
        
        /* Quest Log */
        #questLog { bottom: 20px; right: 20px; width: 300px; background: rgba(0,0,0,0.7); border: 2px solid #fff; border-radius: 10px; padding: 15px; }
        #questLog h3 { margin: 0 0 10px 0; color: #ffd700; }
        #questLog ul { list-style: none; padding: 0; margin: 0; }
        #questLog li { padding: 5px 0; border-bottom: 1px solid rgba(255,255,255,0.2); }
        
        /* Crosshair */
        #crosshair { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 30px; height: 30px; pointer-events: none; }
        #crosshair::before, #crosshair::after { content: ''; position: absolute; background: #fff; }
        #crosshair::before { width: 100%; height: 2px; top: 50%; left: 0; transform: translateY(-50%); }
        #crosshair::after { width: 2px; height: 100%; top: 0; left: 50%; transform: translateX(-50%); }
        
        /* Vehicle HUD */
        #vehicleHUD { top: 120px; left: 20px; display: none; }
        .speedometer { font-size: 18px; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px; border: 2px solid #fff; }
        
        /* Damage Numbers */
        .damage-number { position: absolute; color: #ff0000; font-size: 24px; font-weight: bold; pointer-events: none; animation: damageFloat 1s ease-out forwards; }
        @keyframes damageFloat {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-50px); opacity: 0; }
        }
        
        /* UI Panels */
        #inventory { top: 50%; left: 50%; transform: translate(-50%, -50%); width: 800px; height: 600px; background: linear-gradient(135deg, rgba(0,0,0,0.9), rgba(20,20,20,0.9)); border: 2px solid #fff; border-radius: 15px; padding: 20px; display: none; box-shadow: 0 0 30px rgba(255,255,255,0.3); }
        #inventory h2 { margin: 0 0 20px 0; color: #ffd700; text-align: center; }
        #inventoryTabs { display: flex; gap: 10px; margin-bottom: 20px; }
        .inventory-tab { padding: 10px 20px; background: rgba(255,255,255,0.1); border: 1px solid #666; border-radius: 5px; cursor: pointer; transition: all 0.2s; }
        .inventory-tab:hover { background: rgba(255,255,255,0.2); }
        .inventory-tab.active { background: rgba(255,215,0,0.3); border-color: #ffd700; }
        #inventoryContent { height: 400px; overflow-y: auto; }
        #inventoryGrid { display: grid; grid-template-columns: repeat(8, 1fr); gap: 10px; }
        .inventorySlot { width: 60px; height: 60px; background: rgba(255,255,255,0.1); border: 2px solid #666; border-radius: 10px; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; font-size: 24px; }
        .inventorySlot:hover { border-color: #fff; background: rgba(255,255,255,0.2); transform: scale(1.05); }
        .inventorySlot.equipped { border-color: #ffd700; box-shadow: 0 0 10px rgba(255,215,0,0.5); }
        
        /* Marketplace */
        #marketplace { top: 50%; left: 50%; transform: translate(-50%, -50%); width: 900px; height: 600px; background: linear-gradient(135deg, rgba(0,0,0,0.9), rgba(20,20,20,0.9)); border: 2px solid #fff; border-radius: 15px; padding: 20px; display: none; }
        #marketplace h2 { text-align: center; color: #ffd700; margin-bottom: 20px; }
        #marketTabs { display: flex; gap: 10px; margin-bottom: 20px; }
        .market-tab { padding: 10px 20px; background: rgba(255,255,255,0.1); border: 1px solid #666; border-radius: 5px; cursor: pointer; transition: all 0.2s; }
        .market-tab:hover { background: rgba(255,255,255,0.2); }
        .market-tab.active { background: rgba(255,215,0,0.3); border-color: #ffd700; }
        #marketGrid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; }
        .market-item { padding: 15px; background: rgba(255,255,255,0.1); border: 2px solid #666; border-radius: 10px; cursor: pointer; transition: all 0.2s; }
        .market-item:hover { background: rgba(255,255,255,0.2); border-color: #fff; }
        .market-item h4 { margin: 0 0 10px 0; color: #ffd700; }
        .market-item .price { color: #0f0; font-weight: bold; }
        
        /* Achievements */
        #achievements { top: 50%; left: 50%; transform: translate(-50%, -50%); width: 800px; height: 600px; background: linear-gradient(135deg, rgba(0,0,0,0.9), rgba(20,20,20,0.9)); border: 2px solid #fff; border-radius: 15px; padding: 20px; display: none; }
        #achievements h2 { text-align: center; color: #ffd700; margin-bottom: 20px; }
        #achievementGrid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; max-height: 500px; overflow-y: auto; }
        .achievement { padding: 15px; background: rgba(255,255,255,0.1); border: 2px solid #666; border-radius: 10px; text-align: center; transition: all 0.2s; }
        .achievement.unlocked { border-color: #ffd700; background: rgba(255,215,0,0.2); }
        .achievement h4 { margin: 0 0 10px 0; color: #ffd700; }
        .achievement .description { font-size: 14px; color: #ccc; margin-bottom: 10px; }
        .achievement .progress { width: 100%; height: 10px; background: rgba(255,255,255,0.2); border-radius: 5px; overflow: hidden; margin-top: 10px; }
        .achievement .progress-fill { height: 100%; background: #ffd700; width: 0%; transition: width 0.3s; }
        
        /* Leaderboards */
        #leaderboards { top: 50%; left: 50%; transform: translate(-50%, -50%); width: 600px; height: 500px; background: linear-gradient(135deg, rgba(0,0,0,0.9), rgba(20,20,20,0.9)); border: 2px solid #fff; border-radius: 15px; padding: 20px; display: none; }
        #leaderboards h2 { text-align: center; color: #ffd700; margin-bottom: 20px; }
        #leaderboardTabs { display: flex; gap: 10px; margin-bottom: 20px; }
        .leaderboard-tab { padding: 10px 20px; background: rgba(255,255,255,0.1); border: 1px solid #666; border-radius: 5px; cursor: pointer; transition: all 0.2s; }
        .leaderboard-tab:hover { background: rgba(255,255,255,0.2); }
        .leaderboard-tab.active { background: rgba(255,215,0,0.3); border-color: #ffd700; }
        #leaderboardList { max-height: 350px; overflow-y: auto; }
        .leaderboard-entry { display: flex; justify-content: space-between; padding: 10px; margin: 5px 0; background: rgba(255,255,255,0.1); border-radius: 5px; }
        .leaderboard-entry.current { background: rgba(255,215,0,0.2); border: 1px solid #ffd700; }
        .leaderboard-rank { font-weight: bold; color: #ffd700; }
        .leaderboard-name { flex: 1; margin: 0 20px; }
        .leaderboard-score { color: #0f0; }
        
        /* Guild System */
        #guildPanel { top: 50%; left: 50%; transform: translate(-50%, -50%); width: 700px; height: 500px; background: linear-gradient(135deg, rgba(0,0,0,0.9), rgba(20,20,20,0.9)); border: 2px solid #fff; border-radius: 15px; padding: 20px; display: none; }
        #guildPanel h2 { text-align: center; color: #ffd700; margin-bottom: 20px; }
        #guildInfo { background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px; margin-bottom: 20px; }
        #guildMembers { max-height: 200px; overflow-y: auto; margin-bottom: 20px; }
        .guild-member { display: flex; justify-content: space-between; padding: 10px; margin: 5px 0; background: rgba(255,255,255,0.1); border-radius: 5px; }
        .guild-member-name { flex: 1; }
        .guild-member-rank { color: #ffd700; }
        
        /* Mini-games */
        #minigames { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); display: none; z-index: 300; }
        #minigameContent { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 80%; height: 80%; background: rgba(20,20,20,0.9); border: 3px solid #fff; border-radius: 15px; padding: 20px; }
        #minigameCanvas { width: 100%; height: 400px; background: #000; border-radius: 10px; margin-bottom: 20px; }
        #minigameControls { display: flex; justify-content: center; gap: 20px; }
        .minigame-button { padding: 15px 30px; background: #ff6b6b; border: none; border-radius: 10px; color: white; font-size: 18px; cursor: pointer; transition: all 0.2s; }
        .minigame-button:hover { background: #ff5252; transform: scale(1.05); }
        
        /* Voice Chat */
        #voiceChat { bottom: 100px; left: 20px; width: 200px; background: rgba(0,0,0,0.7); border: 2px solid #fff; border-radius: 10px; padding: 10px; display: none; }
        #voiceChat h4 { margin: 0 0 10px 0; color: #ffd700; }
        #voiceParticipants { max-height: 150px; overflow-y: auto; }
        .voice-participant { display: flex; align-items: center; padding: 5px; margin: 2px 0; background: rgba(255,255,255,0.1); border-radius: 5px; }
        .voice-participant-speaking { background: rgba(0,255,0,0.2); }
        .voice-participant-name { flex: 1; margin-left: 10px; }
        .voice-indicator { width: 10px; height: 10px; border-radius: 50%; background: #666; }
        .voice-indicator.active { background: #0f0; animation: pulse 1s infinite; }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        /* Event Notifications */
        #eventNotifications { position: absolute; top: 200px; right: 20px; width: 300px; }
        .event-notification { background: rgba(255,215,0,0.9); color: #000; padding: 15px; margin: 10px 0; border-radius: 10px; box-shadow: 0 0 20px rgba(255,215,0,0.5); animation: slideIn 0.5s ease-out; }
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        /* Pet HUD */
        #petHUD { bottom: 150px; left: 20px; width: 200px; background: rgba(0,0,0,0.7); border: 2px solid #fff; border-radius: 10px; padding: 10px; display: none; }
        #petHUD h4 { margin: 0 0 10px 0; color: #ffd700; }
        #petHealth { width: 100%; height: 10px; background: #333; border-radius: 5px; overflow: hidden; margin-top: 5px; }
        #petHealthFill { height: 100%; background: #0f0; width: 100%; }
        #petHappiness { width: 100%; height: 10px; background: #333; border-radius: 5px; overflow: hidden; margin-top: 5px; }
        #petHappinessFill { height: 100%; background: #ff69b4; width: 100%; }
        
        /* Mount HUD */
        #mountHUD { top: 200px; left: 20px; width: 200px; background: rgba(0,0,0,0.7); border: 2px solid #fff; border-radius: 10px; padding: 10px; display: none; }
        #mountHUD h4 { margin: 0 0 10px 0; color: #ffd700; }
        #mountStamina { width: 100%; height: 10px; background: #333; border-radius: 5px; overflow: hidden; margin-top: 5px; }
        #mountStaminaFill { height: 100%; background: #00ffff; width: 100%; }
        
        /* Loading Screen */
        #loadingScreen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(135deg, #000, #222); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000; }
        #loadingText { font-size: 32px; margin-bottom: 20px; color: #ffd700; }
        #loadingBar { width: 300px; height: 20px; background: rgba(255,255,255,0.2); border-radius: 10px; overflow: hidden; }
        #loadingProgress { height: 100%; background: linear-gradient(90deg, #ffd700, #ff6b6b); width: 0%; transition: width 0.3s; }
        
        /* Sound Toggle */
        #soundToggle { top: 20px; left: 50%; transform: translateX(-50%); padding: 10px 20px; background: rgba(0,0,0,0.7); border: 2px solid #fff; border-radius: 25px; cursor: pointer; transition: all 0.2s; }
        #soundToggle:hover { background: rgba(255,255,255,0.2); }
    </style>
</head>
<body>
    <div id="loadingScreen">
        <div id="loadingText">Loading Shadow Legion: Eternal Wars - Ultimate Pro Edition...</div>
        <div id="loadingBar">
            <div id="loadingProgress"></div>
        </div>
    </div>
    
    <div id="gameCanvas"></div>
    <div id="ui">
        <!-- Main HUD -->
        <div id="healthBar" class="ui-element"><div id="healthFill"></div></div>
        <div id="staminaBar" class="ui-element"><div id="staminaFill"></div></div>
        <div id="ammo" class="ui-element">Ammo: 30/90</div>
        <div id="weaponInfo" class="ui-element">Weapon: Assault Rifle</div>
        <div id="levelInfo" class="ui-element">Level: 1 | XP: 0/100</div>
        <div id="currency" class="ui-element">Gold: 100</div>
        
        <!-- Abilities -->
        <div id="abilities" class="ui-element">
            <div class="ability" data-ability="q">
                Q
                <div class="cooldown-overlay" style="height: 100%;"></div>
            </div>
            <div class="ability" data-ability="w">
                W
                <div class="cooldown-overlay" style="height: 100%;"></div>
            </div>
            <div class="ability" data-ability="e">
                E
                <div class="cooldown-overlay" style="height: 100%;"></div>
            </div>
            <div class="ability" data-ability="r">
                R
                <div class="cooldown-overlay" style="height: 100%;"></div>
            </div>
        </div>
        
        <!-- Minimap -->
        <div id="minimap" class="ui-element">
            <canvas id="minimapCanvas"></canvas>
        </div>
        
        <!-- Quest Log -->
        <div id="questLog" class="ui-element">
            <h3>Quests</h3>
            <ul id="questList">
                <li data-quest="1">[Active] Find the Lost Artifact</li>
                <li data-quest="2">[Active] Defeat the Shadow Boss</li>
            </ul>
        </div>
        
        <!-- Crosshair -->
        <div id="crosshair"></div>
        
        <!-- Vehicle HUD -->
        <div id="vehicleHUD" class="ui-element">
            <div class="speedometer">Speed: <span id="speed">0</span> km/h</div>
        </div>
        
        <!-- Pet HUD -->
        <div id="petHUD" class="ui-element">
            <h4>Pet: Wolf</h4>
            <div>Health: <span id="petHealthText">100/100</span></div>
            <div id="petHealth"><div id="petHealthFill"></div></div>
            <div>Happiness: <span id="petHappinessText">100/100</span></div>
            <div id="petHappiness"><div id="petHappinessFill"></div></div>
        </div>
        
        <!-- Mount HUD -->
        <div id="mountHUD" class="ui-element">
            <h4>Mount: Horse</h4>
            <div>Stamina: <span id="mountStaminaText">100/100</span></div>
            <div id="mountStamina"><div id="mountStaminaFill"></div></div>
        </div>
        
        <!-- Voice Chat -->
        <div id="voiceChat" class="ui-element">
            <h4>Voice Chat</h4>
            <div id="voiceParticipants"></div>
        </div>
        
        <!-- Event Notifications -->
        <div id="eventNotifications"></div>
        
        <!-- Inventory -->
        <div id="inventory" class="ui-element">
            <h2>Inventory</h2>
            <div id="inventoryTabs">
                <div class="inventory-tab active" onclick="switchInventoryTab('items')">Items</div>
                <div class="inventory-tab" onclick="switchInventoryTab('weapons')">Weapons</div>
                <div class="inventory-tab" onclick="switchInventoryTab('armor')">Armor</div>
                <div class="inventory-tab" onclick="switchInventoryTab('pets')">Pets</div>
                <div class="inventory-tab" onclick="switchInventoryTab('mounts')">Mounts</div>
            </div>
            <div id="inventoryContent">
                <div id="inventoryGrid"></div>
            </div>
            <button onclick="closeInventory()" style="margin-top: 20px; padding: 10px 20px; background: #ff6b6b; border: none; border-radius: 5px; color: white; cursor: pointer;">Close</button>
        </div>
        
        <!-- Marketplace -->
        <div id="marketplace" class="ui-element">
            <h2>Marketplace</h2>
            <div id="marketTabs">
                <div class="market-tab active" onclick="switchMarketTab('weapons')">Weapons</div>
                <div class="market-tab" onclick="switchMarketTab('armor')">Armor</div>
                <div class="market-tab" onclick="switchMarketTab('items')">Items</div>
                <div class="market-tab" onclick="switchMarketTab('pets')">Pets</div>
                <div class="market-tab" onclick="switchMarketTab('mounts')">Mounts</div>
            </div>
            <div id="marketGrid"></div>
            <button onclick="closeMarketplace()" style="margin-top: 20px; padding: 10px 20px; background: #ff6b6b; border: none; border-radius: 5px; color: white; cursor: pointer;">Close</button>
        </div>
        
        <!-- Achievements -->
        <div id="achievements" class="ui-element">
            <h2>Achievements</h2>
            <div id="achievementGrid"></div>
            <button onclick="closeAchievements()" style="margin-top: 20px; padding: 10px 20px; background: #ff6b6b; border: none; border-radius: 5px; color: white; cursor: pointer;">Close</button>
        </div>
        
        <!-- Leaderboards -->
        <div id="leaderboards" class="ui-element">
            <h2>Leaderboards</h2>
            <div id="leaderboardTabs">
                <div class="leaderboard-tab active" onclick="switchLeaderboardTab('global')">Global</div>
                <div class="leaderboard-tab" onclick="switchLeaderboardTab('friends')">Friends</div>
                <div class="leaderboard-tab" onclick="switchLeaderboardTab('guild')">Guild</div>
            </div>
            <div id="leaderboardList"></div>
            <button onclick="closeLeaderboards()" style="margin-top: 20px; padding: 10px 20px; background: #ff6b6b; border: none; border-radius: 5px; color: white; cursor: pointer;">Close</button>
        </div>
        
        <!-- Guild Panel -->
        <div id="guildPanel" class="ui-element">
            <h2>Guild</h2>
            <div id="guildInfo">
                <h3 id="guildName">Shadow Legion</h3>
                <p>Members: <span id="guildMemberCount">1</span>/50</p>
                <p>Level: <span id="guildLevel">1</span></p>
                <p>Gold: <span id="guildGold">0</span></p>
            </div>
            <div id="guildMembers"></div>
            <button onclick="leaveGuild()" style="padding: 10px 20px; background: #ff6b6b; border: none; border-radius: 5px; color: white; cursor: pointer;">Leave Guild</button>
            <button onclick="closeGuildPanel()" style="margin-left: 10px; padding: 10px 20px; background: #4CAF50; border: none; border-radius: 5px; color: white; cursor: pointer;">Close</button>
        </div>
        
        <!-- Mini-games -->
        <div id="minigames">
            <div id="minigameContent">
                <h2 id="minigameTitle">Fishing</h2>
                <canvas id="minigameCanvas"></canvas>
                <div id="minigameControls">
                    <button class="minigame-button" onclick="startMinigame('fishing')">Start Fishing</button>
                    <button class="minigame-button" onclick="startMinigame('hunting')">Start Hunting</button>
                    <button class="minigame-button" onclick="closeMinigames()">Close</button>
                </div>
            </div>
        </div>
        
        <!-- Sound Toggle -->
        <div id="soundToggle" class="ui-element" onclick="toggleSound()">ðŸ”Š Sound ON</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script>
        // Ultimate Pro Game State
        const game = {
            scene: null,
            camera: null,
            renderer: null,
            world: null,
            player: {
                mesh: null,
                body: null,
                x: 0, y: 0, z: 0,
                yaw: 0, pitch: 0,
                health: 100, maxHealth: 100,
                stamina: 100, maxStamina: 100,
                ammo: 30, maxAmmo: 90,
                inVehicle: false,
                vehicle: null,
                onMount: false,
                mount: null,
                inventory: [
                    { id: 1, name: 'Health Potion', type: 'consumable', icon: 'ðŸ§ª', quantity: 3 },
                    { id: 2, name: 'Sword', type: 'weapon', icon: 'âš”ï¸', equipped: true },
                    { id: 3, name: 'Key', type: 'quest', icon: 'ðŸ—ï¸', quantity: 1 },
                    { id: 4, name: 'Herbs', type: 'crafting', icon: 'ðŸŒ¿', quantity: 5 },
                    { id: 5, name: 'Metal', type: 'crafting', icon: 'ðŸ”§', quantity: 10 },
                    { id: 6, name: 'Wood', type: 'crafting', icon: 'ðŸªµ', quantity: 15 },
                    { id: 7, name: 'Wolf Pet', type: 'pet', icon: 'ðŸº', active: false },
                    { id: 8, name: 'Horse Mount', type: 'mount', icon: 'ðŸ´', active: false }
                ],
                velocity: new THREE.Vector3(),
                isGrounded: false,
                isJumping: false,
                weapons: [
                    { name: 'Assault Rifle', damage: 25, ammo: 30, maxAmmo: 90, fireRate: 100, reloadTime: 2000, level: 1 },
                    { name: 'Shotgun', damage: 50, ammo: 8, maxAmmo: 24, fireRate: 500, reloadTime: 3000, level: 1 },
                    { name: 'Sniper Rifle', damage: 100, ammo: 5, maxAmmo: 15, fireRate: 1000, reloadTime: 4000, level: 1 },
                    { name: 'Pistol', damage: 15, ammo: 12, maxAmmo: 48, fireRate: 200, reloadTime: 1500, level: 1 }
                ],
                currentWeapon: 0,
                lastShot: 0,
                isReloading: false,
                level: 1,
                xp: 0,
                xpToNext: 100,
                skillPoints: 0,
                skills: {
                    damage: 0,
                    speed: 0,
                    critical: 0,
                    fireball: 0,
                    heal: 0,
                    teleport: 0,
                    invisibility: 0,
                    lockpick: 0,
                    assassinate: 0
                },
                companion: null,
                pet: null,
                base: {
                    structures: [],
                    resources: {
                        wood: 100,
                        metal: 50,
                        food: 30
                    }
                },
                currency: 100,
                guild: null,
                achievements: {},
                stats: {
                    kills: 0,
                    deaths: 0,
                    playTime: 0,
                    distanceTraveled: 0,
                    itemsCrafted: 0,
                    questsCompleted: 0
                }
            },
            keys: {},
            abilities: {
                q: { name: 'Fireball', cooldown: 0, maxCooldown: 5000, icon: 'ðŸ”¥', unlocked: false },
                w: { name: 'Heal', cooldown: 0, maxCooldown: 10000, icon: 'ðŸ’š', unlocked: false },
                e: { name: 'Dash', cooldown: 0, maxCooldown: 3000, icon: 'ðŸ’¨', unlocked: true },
                r: { name: 'Ultimate', cooldown: 0, maxCooldown: 60000, icon: 'ðŸ’€', unlocked: false }
            },
            quests: [
                { id: 1, name: 'Find the Lost Artifact', completed: false, objectives: ['Search the ruins', 'Find the artifact', 'Return to town'] },
                { id: 2, name: 'Defeat the Shadow Boss', completed: false, objectives: ['Locate the boss', 'Defeat the boss', 'Collect reward'] },
                { id: 3, name: 'Build a Base', completed: false, objectives: ['Gather resources', 'Build walls', 'Build a workshop'] }
            ],
            npcs: [],
            enemies: [],
            vehicles: [],
            particles: [],
            structures: [],
            companions: [],
            pets: [],
            mounts: [],
            soundEnabled: true,
            currentDialogue: null,
            clock: new THREE.Clock(),
            raycaster: new THREE.Raycaster(),
            mouse: new THREE.Vector3(),
            audioListener: null,
            sounds: {},
            minimapCtx: null,
            gameMode: 'story',
            multiplayer: {
                enabled: false,
                players: [],
                socket: null,
                roomId: null,
                voiceChat: false,
                voiceStream: null
            },
            weather: {
                current: 'clear',
                intensity: 0,
                particles: []
            },
            timeOfDay: 12,
            dayNightSpeed: 0.1,
            marketplace: {
                items: [
                    { id: 1, name: 'Iron Sword', type: 'weapon', price: 50, icon: 'âš”ï¸' },
                    { id: 2, name: 'Steel Armor', type: 'armor', price: 100, icon: 'ðŸ›¡ï¸' },
                    { id: 3, name: 'Health Potion', type: 'consumable', price: 10, icon: 'ðŸ§ª' },
                    { id: 4, name: 'Wolf Pet', type: 'pet', price: 200, icon: 'ðŸº' },
                    { id: 5, name: 'Horse Mount', type: 'mount', price: 300, icon: 'ðŸ´' }
                ]
            },
            achievements: [
                { id: 'first_kill', name: 'First Kill', description: 'Defeat your first enemy', unlocked: false },
                { id: 'level_10', name: 'Level 10', description: 'Reach level 10', unlocked: false },
                { id: 'craft_master', name: 'Craft Master', description: 'Craft 50 items', unlocked: false },
                { id: 'explorer', name: 'Explorer', description: 'Travel 1000 meters', unlocked: false },
                { id: 'guild_member', name: 'Guild Member', description: 'Join a guild', unlocked: false }
            ],
            leaderboards: {
                global: [
                    { name: 'ProPlayer', score: 10000 },
                    { name: 'GamerGirl', score: 8500 },
                    { name: 'ShadowNinja', score: 7200 }
                ],
                friends: [],
                guild: []
            },
            guilds: [],
            events: [],
            pathfinding: {
                grid: [],
                gridSize: 10,
                gridWidth: 100,
                gridHeight: 100
            }
        };

        // Loading simulation
        let loadingProgress = 0;
        const loadingSteps = [
            { progress: 5, text: 'Initializing engine...' },
            { progress: 15, text: 'Loading textures...' },
            { progress: 30, text: 'Setting up physics...' },
            { progress: 45, text: 'Creating world...' },
            { progress: 60, text: 'Loading models...' },
            { progress: 75, text: 'Initializing multiplayer...' },
            { progress: 85, text: 'Setting up audio...' },
            { progress: 95, text: 'Finalizing...' },
            { progress: 100, text: 'Ready to play!' }
        ];
        
        let currentStep = 0;
        const loadingInterval = setInterval(() => {
            if (currentStep < loadingSteps.length) {
                const step = loadingSteps[currentStep];
                loadingProgress = step.progress;
                document.getElementById('loadingProgress').style.width = loadingProgress + '%';
                document.getElementById('loadingText').textContent = 'Loading Shadow Legion: Eternal Wars - ' + step.text;
                
                if (loadingProgress >= 100) {
                    clearInterval(loadingInterval);
                    setTimeout(() => {
                        document.getElementById('loadingScreen').style.display = 'none';
                        initThreeJS();
                    }, 1000);
                }
                currentStep++;
            }
        }, 400);

        // Initialize Three.js with all features
        function initThreeJS() {
            // Scene
            game.scene = new THREE.Scene();
            game.scene.fog = new THREE.FogExp2(0x000000, 0.01);

            // Camera
            game.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            game.camera.position.set(0, 2, 0);

            // Renderer
            game.renderer = new THREE.WebGLRenderer({ antialias: true });
            game.renderer.setSize(window.innerWidth, window.innerHeight);
            game.renderer.shadowMap.enabled = true;
            game.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            game.renderer.toneMapping = THREE.ACESFilmicToneMapping;
            game.renderer.toneMappingExposure = 1.0;
            document.getElementById('gameCanvas').appendChild(game.renderer.domElement);

            // Physics World
            game.world = new CANNON.World();
            game.world.gravity.set(0, -9.82, 0);
            game.world.broadphase = new CANNON.NaiveBroadphase();
            game.world.solver.iterations = 10;

            // Audio Listener
            game.audioListener = new THREE.AudioListener();
            game.camera.add(game.audioListener);

            // Enhanced Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
            game.scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            game.scene.add(directionalLight);

            // Hemisphere lighting
            const hemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0x545454, 0.5);
            game.scene.add(hemisphereLight);

            // Skybox
            const skyboxGeometry = new THREE.BoxGeometry(1000, 1000, 1000);
            const skyboxMaterials = [
                new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('https://picsum.photos/seed/skybox-right/1024/1024.jpg'), side: THREE.BackSide }),
                new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('https://picsum.photos/seed/skybox-left/1024/1024.jpg'), side: THREE.BackSide }),
                new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('https://picsum.photos/seed/skybox-top/1024/1024.jpg'), side: THREE.BackSide }),
                new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('https://picsum.photos/seed/skybox-bottom/1024/1024.jpg'), side: THREE.BackSide }),
                new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('https://picsum.photos/seed/skybox-front/1024/1024.jpg'), side: THREE.BackSide }),
                new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('https://picsum.photos/seed/skybox-back/1024/1024.jpg'), side: THREE.BackSide })
            ];
            const skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterials);
            game.scene.add(skybox);

            // Create enhanced world
            createEnhancedWorld();
            createPlayer();
            createNPCs();
            createEnemies();
            createVehicles();
            createCompanions();
            createPets();
            createMounts();
            initPathfinding();
            initMinimap();
            initSounds();
            initWeather();
            initAchievements();
            initLeaderboards();
            initEvents();
            loadSaveData();

            // Start game loop
            animate();
        }

        // Initialize pathfinding grid
        function initPathfinding() {
            const { gridSize, gridWidth, gridHeight } = game.pathfinding;
            game.pathfinding.grid = Array(gridHeight).fill().map(() => Array(gridWidth).fill(0));
            
            // Mark obstacles
            game.structures.forEach(structure => {
                const gridX = Math.floor(structure.position.x / gridSize);
                const gridZ = Math.floor(structure.position.z / gridSize);
                if (gridX >= 0 && gridX < gridWidth && gridZ >= 0 && gridZ < gridHeight) {
                    game.pathfinding.grid[gridZ][gridX] = 1;
                }
            });
        }

        // A* Pathfinding Algorithm
        function findPath(start, end) {
            const { grid, gridSize } = game.pathfinding;
            const startNode = {
                x: Math.floor(start.x / gridSize),
                z: Math.floor(start.z / gridSize),
                g: 0,
                h: 0,
                f: 0,
                parent: null
            };
            const endNode = {
                x: Math.floor(end.x / gridSize),
                z: Math.floor(end.z / gridSize)
            };

            const openList = [];
            const closedList = [];
            openList.push(startNode);

            while (openList.length > 0) {
                let currentNode = openList[0];
                let currentIndex = 0;

                openList.forEach((node, index) => {
                    if (node.f < currentNode.f) {
                        currentNode = node;
                        currentIndex = index;
                    }
                });

                openList.splice(currentIndex, 1);
                closedList.push(currentNode);

                if (currentNode.x === endNode.x && currentNode.z === endNode.z) {
                    const path = [];
                    let current = currentNode;
                    while (current) {
                        path.push({
                            x: current.x * gridSize,
                            z: current.z * gridSize
                        });
                        current = current.parent;
                    }
                    return path.reverse();
                }

                const neighbors = [];
                const directions = [
                    { x: 0, z: -1 }, { x: 1, z: 0 }, { x: 0, z: 1 }, { x: -1, z: 0 },
                    { x: -1, z: -1 }, { x: 1, z: -1 }, { x: 1, z: 1 }, { x: -1, z: 1 }
                ];

                directions.forEach(dir => {
                    const newX = currentNode.x + dir.x;
                    const newZ = currentNode.z + dir.z;

                    if (newX >= 0 && newX < game.pathfinding.gridWidth &&
                        newZ >= 0 && newZ < game.pathfinding.gridHeight &&
                        game.pathfinding.grid[newZ][newX] === 0) {
                        neighbors.push({ x: newX, z: newZ });
                    }
                });

                neighbors.forEach(neighbor => {
                    if (closedList.find(node => node.x === neighbor.x && node.z === neighbor.z)) {
                        return;
                    }

                    const g = currentNode.g + (neighbor.x === currentNode.x || neighbor.z === currentNode.z ? 1 : 1.414);
                    const h = Math.sqrt(Math.pow(neighbor.x - endNode.x, 2) + Math.pow(neighbor.z - endNode.z, 2));
                    const f = g + h;

                    const existingNode = openList.find(node => node.x === neighbor.x && node.z === neighbor.z);
                    if (!existingNode) {
                        openList.push({
                            x: neighbor.x,
                            z: neighbor.z,
                            g: g,
                            h: h,
                            f: f,
                            parent: currentNode
                        });
                    } else if (g < existingNode.g) {
                        existingNode.g = g;
                        existingNode.f = f;
                        existingNode.parent = currentNode;
                    }
                });
            }

            return [];
        }

        // Create enhanced world with pathfinding obstacles
        function createEnhancedWorld() {
            // Ground with physics
            const groundGeometry = new THREE.PlaneGeometry(1000, 1000, 50, 50);
            const groundTexture = new THREE.TextureLoader().load('https://picsum.photos/seed/ground-texture/1024/1024.jpg');
            groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
            groundTexture.repeat.set(50, 50);
            const groundMaterial = new THREE.MeshLambertMaterial({ map: groundTexture });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            game.scene.add(ground);

            // Physics ground
            const groundShape = new CANNON.Plane();
            const groundBody = new CANNON.Body({ mass: 0 });
            groundBody.addShape(groundShape);
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            game.world.add(groundBody);

            // Enhanced buildings with physics
            for (let i = 0; i < 30; i++) {
                const buildingGroup = new THREE.Group();
                
                const buildingGeometry = new THREE.BoxGeometry(
                    Math.random() * 20 + 10,
                    Math.random() * 30 + 10,
                    Math.random() * 20 + 10
                );
                const buildingMaterial = new THREE.MeshLambertMaterial({ 
                    color: new THREE.Color().setHSL(Math.random(), 0.5, 0.3) 
                });
                const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                building.castShadow = true;
                building.receiveShadow = true;
                buildingGroup.add(building);

                // Physics body for building
                const buildingShape = new CANNON.Box(new CANNON.Vec3(
                    buildingGeometry.parameters.width / 2,
                    buildingGeometry.parameters.height / 2,
                    buildingGeometry.parameters.depth / 2
                ));
                const buildingBody = new CANNON.Body({ mass: 0 });
                buildingBody.addShape(buildingShape);
                buildingGroup.userData.physicsBody = buildingBody;
                game.world.add(buildingBody);

                // Add windows
                const windowGeometry = new THREE.PlaneGeometry(2, 2);
                const windowMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00,
                    emissive: 0xffff00,
                    emissiveIntensity: 0.5
                });
                
                for (let j = 0; j < 10; j++) {
                    const window = new THREE.Mesh(windowGeometry, windowMaterial);
                    window.position.set(
                        (Math.random() - 0.5) * buildingGeometry.parameters.width * 0.8,
                        (Math.random() - 0.5) * buildingGeometry.parameters.height * 0.8,
                        buildingGeometry.parameters.depth / 2 + 0.1
                    );
                    buildingGroup.add(window);
                }

                const posX = (Math.random() - 0.5) * 200;
                const posY = buildingGeometry.parameters.height / 2;
                const posZ = (Math.random() - 0.5) * 200;
                
                buildingGroup.position.set(posX, posY, posZ);
                buildingBody.position.set(posX, posY, posZ);
                
                game.scene.add(buildingGroup);
                game.structures.push(buildingGroup);
            }

            // Enhanced trees
            for (let i = 0; i < 50; i++) {
                const treeGroup = new THREE.Group();
                
                const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.7, 5);
                const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                
                const leavesGeometry = new THREE.SphereGeometry(3);
                const leavesMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                leaves.position.y = 4;
                
                treeGroup.add(trunk);
                treeGroup.add(leaves);
                treeGroup.position.set(
                    (Math.random() - 0.5) * 300,
                    2.5,
                    (Math.random() - 0.5) * 300
                );
                treeGroup.castShadow = true;
                game.scene.add(treeGroup);
            }

            // Add decorative elements with physics
            for (let i = 0; i < 30; i++) {
                const rockGeometry = new THREE.DodecahedronGeometry(Math.random() * 2 + 0.5);
                const rockMaterial = new THREE.MeshLambertMaterial({ color: 0x696969 });
                const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                
                const posX = (Math.random() - 0.5) * 400;
                const posY = 0.5;
                const posZ = (Math.random() - 0.5) * 400;
                
                rock.position.set(posX, posY, posZ);
                rock.castShadow = true;
                rock.receiveShadow = true;
                game.scene.add(rock);

                // Physics for rocks
                const rockShape = new CANNON.Sphere(rockGeometry.parameters.radius);
                const rockBody = new CANNON.Body({ mass: 1 });
                rockBody.addShape(rockShape);
                rockBody.position.set(posX, posY, posZ);
                game.world.add(rockBody);
                rock.userData.physicsBody = rockBody;
            }
        }

        // Create player with physics
        function createPlayer() {
            const playerGeometry = new THREE.CapsuleGeometry(0.5, 1.8, 4, 8);
            const playerMaterial = new THREE.MeshLambertMaterial({ color: 0x0066cc });
            game.player.mesh = new THREE.Mesh(playerGeometry, playerMaterial);
            game.player.mesh.position.set(0, 1, 0);
            game.player.mesh.castShadow = true;
            game.scene.add(game.player.mesh);

            // Physics body for player
            const playerShape = new CANNON.Sphere(0.5);
            game.player.body = new CANNON.Body({ mass: 5 });
            game.player.body.addShape(playerShape);
            game.player.body.position.set(0, 1, 0);
            game.player.body.linearDamping = 0.4;
            game.world.add(game.player.body);
        }

        // Create pets
        function createPets() {
            const petData = [
                { name: 'Wolf', position: [10, 1, 10], color: 0x8B4513, health: 80, damage: 15, speed: 5 },
                { name: 'Eagle', position: [-10, 3, -10], color: 0x4169E1, health: 50, damage: 10, speed: 8 },
                { name: 'Bear', position: [20, 1, 20], color: 0x654321, health: 120, damage: 25, speed: 3 }
            ];

            petData.forEach(data => {
                const petGroup = new THREE.Group();
                
                let petGeometry;
                if (data.name === 'Wolf') {
                    petGeometry = new THREE.BoxGeometry(1, 0.8, 2);
                } else if (data.name === 'Eagle') {
                    petGeometry = new THREE.SphereGeometry(0.5);
                } else {
                    petGeometry = new THREE.BoxGeometry(1.5, 1.2, 2.5);
                }
                
                const petMaterial = new THREE.MeshLambertMaterial({ color: data.color });
                const pet = new THREE.Mesh(petGeometry, petMaterial);
                pet.castShadow = true;
                petGroup.add(pet);
                
                petGroup.position.set(...data.position);
                petGroup.userData = { 
                    name: data.name, 
                    type: 'pet',
                    health: data.health,
                    maxHealth: data.health,
                    damage: data.damage,
                    speed: data.speed,
                    owner: null,
                    happiness: 100,
                    level: 1,
                    xp: 0
                };
                
                game.scene.add(petGroup);
                game.pets.push(petGroup);
            });
        }

        // Create mounts
        function createMounts() {
            const mountData = [
                { name: 'Horse', position: [15, 1, 15], color: 0x8B4513, speed: 15, stamina: 100 },
                { name: 'Wolf', position: [-15, 1, -15], color: 0x696969, speed: 18, stamina: 80 },
                { name: 'Eagle', position: [25, 5, 25], color: 0x4169E1, speed: 25, stamina: 60 }
            ];

            mountData.forEach(data => {
                const mountGroup = new THREE.Group();
                
                let mountGeometry;
                if (data.name === 'Horse') {
                    mountGeometry = new THREE.BoxGeometry(2, 2, 3);
                } else if (data.name === 'Wolf') {
                    mountGeometry = new THREE.BoxGeometry(1.5, 1.5, 2.5);
                } else {
                    mountGeometry = new THREE.SphereGeometry(1);
                }
                
                const mountMaterial = new THREE.MeshLambertMaterial({ color: data.color });
                const mount = new THREE.Mesh(mountGeometry, mountMaterial);
                mount.castShadow = true;
                mountGroup.add(mount);
                
                mountGroup.position.set(...data.position);
                mountGroup.userData = { 
                    name: data.name, 
                    type: 'mount',
                    speed: data.speed,
                    maxSpeed: data.speed,
                    stamina: data.stamina,
                    maxStamina: data.stamina,
                    owner: null,
                    level: 1
                };
                
                game.scene.add(mountGroup);
                game.mounts.push(mountGroup);
            });
        }

        // Initialize achievements
        function initAchievements() {
            // Load achievements from save or create new
            const savedAchievements = localStorage.getItem('shadowLegionAchievements');
            if (savedAchievements) {
                game.player.achievements = JSON.parse(savedAchievements);
            }
            
            updateAchievementsUI();
        }

        // Initialize leaderboards
        function initLeaderboards() {
            // Simulate loading leaderboards
            updateLeaderboardUI('global');
        }

        // Initialize dynamic events
        function initEvents() {
            // Start random events
            setInterval(() => {
                if (Math.random() < 0.3) {
                    triggerRandomEvent();
                }
            }, 60000); // Every minute
        }

        // Trigger random world event
        function triggerRandomEvent() {
            const events = [
                { name: 'Merchant Arrival', description: 'A merchant has arrived in town!', type: 'merchant' },
                { name: 'Monster Invasion', description: 'Monsters are invading the area!', type: 'invasion' },
                { name: 'Treasure Hunt', description: 'A treasure has been discovered nearby!', type: 'treasure' },
                { name: 'Guild War', description: 'A guild war has broken out!', type: 'guild_war' },
                { name: 'Double XP', description: 'Double XP event active for 10 minutes!', type: 'double_xp' }
            ];
            
            const event = events[Math.floor(Math.random() * events.length)];
            showEventNotification(event.name, event.description);
            
            // Handle event effects
            switch(event.type) {
                case 'double_xp':
                    game.xpMultiplier = 2;
                    setTimeout(() => {
                        game.xpMultiplier = 1;
                        showEventNotification('Event Ended', 'Double XP event has ended.');
                    }, 600000);
                    break;
                case 'invasion':
                    spawnInvasionEnemies();
                    break;
            }
        }

        // Show event notification
        function showEventNotification(title, description) {
            const notification = document.createElement('div');
            notification.className = 'event-notification';
            notification.innerHTML = `
                <h3>${title}</h3>
                <p>${description}</p>
            `;
            document.getElementById('eventNotifications').appendChild(notification);
            
            setTimeout(() => {
                notification.remove();
            }, 10000);
        }

        // Spawn invasion enemies
        function spawnInvasionEnemies() {
            for (let i = 0; i < 10; i++) {
                const enemyGroup = new THREE.Group();
                
                const enemyGeometry = new THREE.CapsuleGeometry(0.5, 1.8, 4, 8);
                const enemyMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
                const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
                enemy.castShadow = true;
                enemyGroup.add(enemy);

                // Add health bar
                const healthBarGeometry = new THREE.PlaneGeometry(2, 0.2);
                const healthBarMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                const healthBar = new THREE.Mesh(healthBarGeometry, healthBarMaterial);
                healthBar.position.y = 2.5;
                enemyGroup.add(healthBar);
                
                // Spawn around player
                const angle = (i / 10) * Math.PI * 2;
                const distance = 20;
                enemyGroup.position.set(
                    game.player.mesh.position.x + Math.cos(angle) * distance,
                    1,
                    game.player.mesh.position.z + Math.sin(angle) * distance
                );
                
                enemyGroup.userData = { 
                    name: 'Invader', 
                    type: 'enemy',
                    health: 150,
                    maxHealth: 150,
                    damage: 20,
                    speed: 4,
                    healthBar: healthBar,
                    lastAttack: 0,
                    state: 'chase'
                };
                
                game.scene.add(enemyGroup);
                game.enemies.push(enemyGroup);
            }
        }

        // Initialize other systems (similar to previous version)
        function createNPCs() {
            // ... (similar to previous implementation)
        }

        function createEnemies() {
            // ... (similar to previous implementation)
        }

        function createVehicles() {
            // ... (similar to previous implementation)
        }

        function createCompanions() {
            // ... (similar to previous implementation)
        }

        function initMinimap() {
            // ... (similar to previous implementation)
        }

        function initSounds() {
            // ... (similar to previous implementation)
        }

        function initWeather() {
            // ... (similar to previous implementation)
        }

        function loadSaveData() {
            // ... (similar to previous implementation)
        }

        // Enhanced input handling
        document.addEventListener('keydown', (e) => {
            game.keys[e.key.toLowerCase()] = true;
            
            if (e.key === ' ') shoot();
            if (e.key === 'r') reloadWeapon();
            if (e.key === 'i') openInventory();
            if (e.key === 'm') openMap();
            if (e.key === 'f') interact();
            if (e.key === 'Enter' && game.player.inVehicle) exitVehicle();
            if (e.key === 'Tab') {
                e.preventDefault();
                toggleWeaponWheel();
            }
            if (e.key >= '1' && e.key <= '4') {
                game.player.currentWeapon = parseInt(e.key) - 1;
                updateWeaponInfo();
            }
            if (e.key === 'k') openSkillTree();
            if (e.key === 'c') openCrafting();
            if (e.key === 'b') openBuildMenu();
            if (e.key === 'Escape') openSaveLoadMenu();
            if (e.key === 'p') openMarketplace();
            if (e.key === 'a') openAchievements();
            if (e.key === 'l') openLeaderboards();
            if (e.key === 'g') openGuildPanel();
            if (e.key === 'v') toggleVoiceChat();
            if (e.key === 'n') openMinigames();
        });

        document.addEventListener('keyup', (e) => {
            game.keys[e.key.toLowerCase()] = false;
        });

        // Mouse look with sensitivity
        document.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement === game.renderer.domElement) {
                const sensitivity = 0.002;
                game.player.yaw -= e.movementX * sensitivity;
                game.player.pitch -= e.movementY * sensitivity;
                game.player.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, game.player.pitch));
            }
        });

        // Click to lock pointer
        game.renderer.domElement.addEventListener('click', () => {
            game.renderer.domElement.requestPointerLock();
        });

        // Enhanced shooting with critical hits
        function shoot() {
            // ... (similar to previous implementation)
        }

        // Gain XP and level up
        function gainXP(amount) {
            if (game.xpMultiplier) {
                amount *= game.xpMultiplier;
            }
            
            game.player.xp += amount;
            
            while (game.player.xp >= game.player.xpToNext) {
                game.player.xp -= game.player.xpToNext;
                game.player.level++;
                game.player.skillPoints += 2;
                game.player.maxHealth += 10;
                game.player.health = game.player.maxHealth;
                game.player.xpToNext = game.player.level * 100;
                
                console.log(`LEVEL UP! Now level ${game.player.level}`);
                updateLevelInfo();
                updateSkillPoints();
                updateHealth();
                
                // Check achievements
                checkAchievement('level_10', game.player.level >= 10);
            }
            
            updateLevelInfo();
        }

        // Check and unlock achievements
        function checkAchievement(achievementId, condition) {
            if (!game.player.achievements[achievementId] && condition) {
                game.player.achievements[achievementId] = true;
                showEventNotification('Achievement Unlocked!', game.achievements.find(a => a.id === achievementId).name);
                updateAchievementsUI();
                
                // Save achievements
                localStorage.setItem('shadowLegionAchievements', JSON.stringify(game.player.achievements));
            }
        }

        // Reload weapon
        function reloadWeapon() {
            // ... (similar to previous implementation)
        }

        // Enhanced movement with physics and mounts
        function updateMovement(deltaTime) {
            let speed = game.player.inVehicle ? 50 : (game.keys['shift'] ? 10 : 5);
            
            // Apply mount speed bonus
            if (game.player.onMount && game.player.mount) {
                speed = game.player.mount.userData.speed;
            }
            
            // Apply skill speed bonus
            speed += game.player.skills.speed * 2;
            
            const direction = new THREE.Vector3();
            
            if (game.keys['w']) direction.z -= 1;
            if (game.keys['s']) direction.z += 1;
            if (game.keys['a']) direction.x -= 1;
            if (game.keys['d']) direction.x += 1;
            
            direction.normalize();
            direction.multiplyScalar(speed * deltaTime);
            
            // Track distance for achievement
            if (direction.length() > 0) {
                game.player.stats.distanceTraveled += direction.length();
                checkAchievement('explorer', game.player.stats.distanceTraveled >= 1000);
            }
            
            // Apply rotation
            direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), game.player.yaw);
            
            // Apply physics force
            if (game.player.body) {
                const force = new CANNON.Vec3(direction.x, 0, direction.z);
                force.scale(10, force);
                game.player.body.applyForce(force, game.player.body.position);
                
                // Update mesh position to match physics
                game.player.mesh.position.copy(game.player.body.position);
                game.player.mesh.position.y -= 0.5; // Offset for capsule
            }
            
            // Update camera position
            game.camera.position.copy(game.player.mesh.position);
            game.camera.position.y += 1.8;
            
            // Jumping
            if (game.keys[' '] && game.player.isGrounded && !game.player.isJumping) {
                if (game.player.body) {
                    game.player.body.velocity.y = 8;
                    game.player.isJumping = true;
                    game.player.isGrounded = false;
                }
            }
            
            // Check if grounded
            if (game.player.body) {
                game.player.isGrounded = Math.abs(game.player.body.velocity.y) < 0.1;
                if (game.player.isGrounded) {
                    game.player.isJumping = false;
                }
            }
            
            // Update camera rotation
            game.camera.rotation.order = 'YXZ';
            game.camera.rotation.y = game.player.yaw;
            game.camera.rotation.x = game.player.pitch;
            
            // Stamina with skill bonus
            const staminaDrain = game.keys['shift'] && game.player.stamina > 0 && !game.player.inVehicle ? 
                (20 - game.player.skills.speed * 2) * deltaTime : 0;
            const staminaRegen = game.player.stamina < game.player.maxStamina ? 
                (10 + game.player.skills.speed * 1) * deltaTime : 0;
            
            if (staminaDrain > 0) {
                game.player.stamina -= staminaDrain;
            } else {
                game.player.stamina += staminaRegen;
            }
            updateStamina();
            
            // Update mount stamina
            if (game.player.onMount && game.player.mount) {
                const mount = game.player.mount.userData;
                if (game.keys['shift']) {
                    mount.stamina -= 10 * deltaTime;
                } else {
                    mount.stamina += 5 * deltaTime;
                }
                mount.stamina = Math.max(0, Math.min(mount.maxStamina, mount.stamina));
                updateMountHUD();
            }
            
            // Footstep sounds
            if ((game.keys['w'] || game.keys['s'] || game.keys['a'] || game.keys['d']) && game.player.isGrounded) {
                if (Math.random() < 0.1) {
                    playSound('footstep');
                }
            }
        }

        // Enhanced enemy AI with pathfinding
        function updateEnemies(deltaTime) {
            game.enemies.forEach(enemy => {
                const distance = enemy.position.distanceTo(game.player.mesh.position);
                const now = Date.now();
                
                // State machine
                if (distance < 20) {
                    enemy.userData.state = 'chase';
                } else if (enemy.userData.state === 'chase' && distance > 30) {
                    enemy.userData.state = 'patrol';
                }
                
                if (enemy.userData.state === 'chase') {
                    // Use pathfinding to navigate to player
                    const path = findPath(enemy.position, game.player.mesh.position);
                    if (path.length > 1) {
                        const nextPoint = path[1];
                        const direction = new THREE.Vector3()
                            .subVectors(new THREE.Vector3(nextPoint.x, 0, nextPoint.z), enemy.position)
                            .normalize();
                        enemy.position.add(direction.multiplyScalar(enemy.userData.speed * deltaTime));
                    }
                    
                    // Attack if close
                    if (distance < 3 && now - enemy.userData.lastAttack > 1000) {
                        takeDamage(enemy.userData.damage);
                        enemy.userData.lastAttack = now;
                    }
                } else if (enemy.userData.state === 'patrol') {
                    // Patrol movement
                    const patrolDistance = enemy.position.distanceTo(enemy.userData.patrolTarget);
                    if (patrolDistance < 2) {
                        enemy.userData.patrolTarget = new THREE.Vector3(
                            enemy.position.x + (Math.random() - 0.5) * 20,
                            1,
                            enemy.position.z + (Math.random() - 0.5) * 20
                        );
                    }
                    
                    const direction = new THREE.Vector3()
                        .subVectors(enemy.userData.patrolTarget, enemy.position)
                        .normalize();
                    enemy.position.add(direction.multiplyScalar(1 * deltaTime));
                }
                
                // Face the player when chasing
                if (enemy.userData.state === 'chase') {
                    enemy.lookAt(game.player.mesh.position);
                }
            });
        }

        // Update pets
        function updatePets(deltaTime) {
            if (game.player.pet) {
                const pet = game.player.pet;
                const distance = pet.position.distanceTo(game.player.mesh.position);
                
                // Follow player
                if (distance > 5) {
                    const direction = new THREE.Vector3()
                        .subVectors(game.player.mesh.position, pet.position)
                        .normalize();
                    pet.position.add(direction.multiplyScalar(pet.userData.speed * deltaTime));
                }
                
                // Attack nearby enemies
                game.enemies.forEach(enemy => {
                    const enemyDistance = pet.position.distanceTo(enemy.position);
                    if (enemyDistance < 3) {
                        enemy.userData.health -= pet.userData.damage * deltaTime;
                        updateEnemyHealth(enemy);
                    }
                });
                
                // Update pet happiness
                pet.userData.happiness = Math.max(0, pet.userData.happiness - 0.1 * deltaTime);
                updatePetHUD();
            }
        }

        // Update mounts
        function updateMounts(deltaTime) {
            if (game.player.mount) {
                const mount = game.player.mount;
                
                // Follow player when not ridden
                if (!game.player.onMount) {
                    const distance = mount.position.distanceTo(game.player.mesh.position);
                    if (distance > 5) {
                        const direction = new THREE.Vector3()
                            .subVectors(game.player.mesh.position, mount.position)
                            .normalize();
                        mount.position.add(direction.multiplyScalar(5 * deltaTime));
                    }
                }
            }
        }

        // Update day/night cycle
        function updateDayNightCycle(deltaTime) {
            game.timeOfDay += game.dayNightSpeed * deltaTime;
            if (game.timeOfDay >= 24) {
                game.timeOfDay = 0;
            }
            
            // Update lighting based on time
            const hour = game.timeOfDay;
            let lightIntensity = 1;
            
            if (hour >= 6 && hour <= 18) {
                lightIntensity = 1;
            } else if (hour > 18 && hour <= 20) {
                lightIntensity = 0.5;
            } else if (hour > 20 || hour < 6) {
                lightIntensity = 0.2;
            } else {
                lightIntensity = 0.5;
            }
            
            game.scene.children.forEach(child => {
                if (child.type === 'DirectionalLight') {
                    child.intensity = lightIntensity;
                }
            });
        }

        // Update play time
        function updatePlayTime(deltaTime) {
            game.player.stats.playTime += deltaTime;
        }

        // Particle effects
        function createMuzzleFlash() {
            // ... (similar to previous implementation)
        }

        function createImpactEffect(position, normal) {
            // ... (similar to previous implementation)
        }

        function createExplosion(position) {
            // ... (similar to previous implementation)
        }

        function updateParticles(deltaTime) {
            // ... (similar to previous implementation)
        }

        // Update minimap
        function updateMinimap() {
            // ... (similar to previous implementation)
        }

        // UI Functions
        function showDamageNumber(position, damage) {
            // ... (similar to previous implementation)
        }

        function updateEnemyHealth(enemy) {
            // ... (similar to previous implementation)
        }

        function updateWeaponInfo() {
            // ... (similar to previous implementation)
        }

        function updateLevelInfo() {
            // ... (similar to previous implementation)
        }

        function updateSkillPoints() {
            // ... (similar to previous implementation)
        }

        function updateCurrency() {
            document.getElementById('currency').textContent = `Gold: ${game.player.currency}`;
        }

        function toggleWeaponWheel() {
            // ... (similar to previous implementation)
        }

        // Marketplace system
        function openMarketplace() {
            document.getElementById('marketplace').style.display = 'block';
            renderMarketplace();
        }

        function closeMarketplace() {
            document.getElementById('marketplace').style.display = 'none';
        }

        let currentMarketTab = 'weapons';
        function switchMarketTab(tab) {
            currentMarketTab = tab;
            document.querySelectorAll('.market-tab').forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');
            renderMarketplace();
        }

        function renderMarketplace() {
            const grid = document.getElementById('marketGrid');
            grid.innerHTML = '';
            
            const filteredItems = game.marketplace.items.filter(item => item.type === currentMarketTab);
            
            filteredItems.forEach(item => {
                const itemEl = document.createElement('div');
                itemEl.className = 'market-item';
                itemEl.innerHTML = `
                    <h4>${item.icon} ${item.name}</h4>
                    <div class="price">Price: ${item.price} gold</div>
                `;
                itemEl.onclick = () => buyItem(item);
                grid.appendChild(itemEl);
            });
        }

        function buyItem(item) {
            if (game.player.currency >= item.price) {
                game.player.currency -= item.price;
                game.player.inventory.push({
                    id: Date.now(),
                    name: item.name,
                    type: item.type,
                    icon: item.icon,
                    quantity: 1
                });
                updateCurrency();
                showEventNotification('Purchase Successful', `You bought ${item.name}!`);
            } else {
                showEventNotification('Insufficient Funds', 'You don\'t have enough gold!');
            }
        }

        // Achievements system
        function openAchievements() {
            document.getElementById('achievements').style.display = 'block';
            updateAchievementsUI();
        }

        function closeAchievements() {
            document.getElementById('achievements').style.display = 'none';
        }

        function updateAchievementsUI() {
            const grid = document.getElementById('achievementGrid');
            grid.innerHTML = '';
            
            game.achievements.forEach(achievement => {
                const achEl = document.createElement('div');
                achEl.className = `achievement ${game.player.achievements[achievement.id] ? 'unlocked' : ''}`;
                achEl.innerHTML = `
                    <h4>${achievement.name}</h4>
                    <div class="description">${achievement.description}</div>
                    <div class="progress">
                        <div class="progress-fill" style="width: ${game.player.achievements[achievement.id] ? '100%' : '0%'}"></div>
                    </div>
                `;
                grid.appendChild(achEl);
            });
        }

        // Leaderboards system
        function openLeaderboards() {
            document.getElementById('leaderboards').style.display = 'block';
            updateLeaderboardUI('global');
        }

        function closeLeaderboards() {
            document.getElementById('leaderboards').style.display = 'none';
        }

        let currentLeaderboardTab = 'global';
        function switchLeaderboardTab(tab) {
            currentLeaderboardTab = tab;
            document.querySelectorAll('.leaderboard-tab').forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');
            updateLeaderboardUI(tab);
        }

        function updateLeaderboardUI(type) {
            const list = document.getElementById('leaderboardList');
            list.innerHTML = '';
            
            const data = game.leaderboards[type];
            data.forEach((entry, index) => {
                const entryEl = document.createElement('div');
                entryEl.className = `leaderboard-entry ${entry.name === 'You' ? 'current' : ''}`;
                entryEl.innerHTML = `
                    <span class="leaderboard-rank">#${index + 1}</span>
                    <span class="leaderboard-name">${entry.name}</span>
                    <span class="leaderboard-score">${entry.score}</span>
                `;
                list.appendChild(entryEl);
            });
        }

        // Guild system
        function openGuildPanel() {
            document.getElementById('guildPanel').style.display = 'block';
            updateGuildUI();
        }

        function closeGuildPanel() {
            document.getElementById('guildPanel').style.display = 'none';
        }

        function updateGuildUI() {
            if (game.player.guild) {
                document.getElementById('guildName').textContent = game.player.guild.name;
                document.getElementById('guildMemberCount').textContent = game.player.guild.members.length;
                document.getElementById('guildLevel').textContent = game.player.guild.level;
                document.getElementById('guildGold').textContent = game.player.guild.gold;
                
                const membersList = document.getElementById('guildMembers');
                membersList.innerHTML = '';
                
                game.player.guild.members.forEach(member => {
                    const memberEl = document.createElement('div');
                    memberEl.className = 'guild-member';
                    memberEl.innerHTML = `
                        <span class="guild-member-name">${member.name}</span>
                        <span class="guild-member-rank">${member.rank}</span>
                    `;
                    membersList.appendChild(memberEl);
                });
            } else {
                document.getElementById('guildInfo').innerHTML = '<p>You are not in a guild. Create or join one!</p>';
            }
        }

        function createGuild() {
            const guildName = prompt('Enter guild name:');
            if (guildName) {
                game.player.guild = {
                    name: guildName,
                    level: 1,
                    gold: 0,
                    members: [
                        { name: 'You', rank: 'Leader' }
                    ]
                };
                checkAchievement('guild_member', true);
                updateGuildUI();
                showEventNotification('Guild Created', `You created the guild "${guildName}"!`);
            }
        }

        function leaveGuild() {
            if (game.player.guild) {
                game.player.guild = null;
                updateGuildUI();
                showEventNotification('Guild Left', 'You left your guild.');
            }
        }

        // Voice chat system
        function toggleVoiceChat() {
            game.multiplayer.voiceChat = !game.multiplayer.voiceChat;
            document.getElementById('voiceChat').style.display = game.multiplayer.voiceChat ? 'block' : 'none';
            
            if (game.multiplayer.voiceChat) {
                // Simulate voice chat participants
                const participants = [
                    { name: 'Player2', speaking: false },
                    { name: 'Player3', speaking: true }
                ];
                
                const participantsList = document.getElementById('voiceParticipants');
                participantsList.innerHTML = '';
                
                participants.forEach(participant => {
                    const participantEl = document.createElement('div');
                    participantEl.className = `voice-participant ${participant.speaking ? 'voice-participant-speaking' : ''}`;
                    participantEl.innerHTML = `
                        <div class="voice-indicator ${participant.speaking ? 'active' : ''}"></div>
                        <span class="voice-participant-name">${participant.name}</span>
                    `;
                    participantsList.appendChild(participantEl);
                });
            }
        }

        // Mini-games system
        function openMinigames() {
            document.getElementById('minigames').style.display = 'block';
        }

        function closeMinigames() {
            document.getElementById('minigames').style.display = 'none';
        }

        function startMinigame(type) {
            const canvas = document.getElementById('minigameCanvas');
            const ctx = canvas.getContext('2d');
            
            document.getElementById('minigameTitle').textContent = type.charAt(0).toUpperCase() + type.slice(1);
            
            if (type === 'fishing') {
                startFishingGame(ctx, canvas);
            } else if (type === 'hunting') {
                startHuntingGame(ctx, canvas);
            }
        }

        function startFishingGame(ctx, canvas) {
            let fishPosition = { x: canvas.width / 2, y: 50 };
            let hookPosition = { x: canvas.width / 2, y: canvas.height - 50 };
            let fishing = false;
            let fishCaught = false;
            
            function drawFishingGame() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw water
                ctx.fillStyle = '#4682B4';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw fish
                ctx.fillStyle = '#FF6347';
                ctx.beginPath();
                ctx.arc(fishPosition.x, fishPosition.y, 20, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw fishing line
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(canvas.width / 2, 0);
                ctx.lineTo(hookPosition.x, hookPosition.y);
                ctx.stroke();
                
                // Draw hook
                ctx.fillStyle = '#C0C0C0';
                ctx.beginPath();
                ctx.arc(hookPosition.x, hookPosition.y, 5, 0, Math.PI * 2);
                ctx.fill();
                
                // Move fish
                fishPosition.x += (Math.random() - 0.5) * 4;
                fishPosition.y += (Math.random() - 0.5) * 2;
                
                // Keep fish in bounds
                fishPosition.x = Math.max(20, Math.min(canvas.width - 20, fishPosition.x));
                fishPosition.y = Math.max(20, Math.min(canvas.height - 100, fishPosition.y));
                
                // Check if fish is caught
                if (fishing && !fishCaught) {
                    const distance = Math.sqrt(
                        Math.pow(fishPosition.x - hookPosition.x, 2) + 
                        Math.pow(fishPosition.y - hookPosition.y, 2)
                    );
                    
                    if (distance < 25) {
                        fishCaught = true;
                        showEventNotification('Fish Caught!', 'You caught a fish!');
                        game.player.inventory.push({
                            id: Date.now(),
                            name: 'Fish',
                            type: 'consumable',
                            icon: 'ðŸŸ',
                            quantity: 1
                        });
                    }
                }
                
                if (!fishCaught) {
                    requestAnimationFrame(drawFishingGame);
                }
            }
            
            canvas.addEventListener('click', () => {
                if (!fishing) {
                    fishing = true;
                    hookPosition.x = fishPosition.x;
                    hookPosition.y = fishPosition.y;
                    drawFishingGame();
                }
            });
            
            drawFishingGame();
        }

        function startHuntingGame(ctx, canvas) {
            let animals = [];
            let score = 0;
            let timeLeft = 30;
            
            // Create animals
            for (let i = 0; i < 5; i++) {
                animals.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: 30,
                    speed: 2 + Math.random() * 2,
                    direction: Math.random() * Math.PI * 2
                });
            }
            
            function drawHuntingGame() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw background
                ctx.fillStyle = '#228B22';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw animals
                animals.forEach(animal => {
                    ctx.fillStyle = '#8B4513';
                    ctx.beginPath();
                    ctx.arc(animal.x, animal.y, animal.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Move animals
                    animal.x += Math.cos(animal.direction) * animal.speed;
                    animal.y += Math.sin(animal.direction) * animal.speed;
                    
                    // Bounce off walls
                    if (animal.x < 0 || animal.x > canvas.width) {
                        animal.direction = Math.PI - animal.direction;
                    }
                    if (animal.y < 0 || animal.y > canvas.height) {
                        animal.direction = -animal.direction;
                    }
                });
                
                // Draw UI
                ctx.fillStyle = '#fff';
                ctx.font = '20px Arial';
                ctx.fillText(`Score: ${score}`, 10, 30);
                ctx.fillText(`Time: ${Math.ceil(timeLeft)}`, 10, 60);
                
                // Update timer
                timeLeft -= 0.016;
                
                if (timeLeft > 0) {
                    requestAnimationFrame(drawHuntingGame);
                } else {
                    showEventNotification('Hunting Complete!', `You scored ${score} points!`);
                    if (score > 50) {
                        game.player.inventory.push({
                            id: Date.now(),
                            name: 'Meat',
                            type: 'consumable',
                            icon: 'ðŸ–',
                            quantity: Math.floor(score / 10)
                        });
                    }
                }
            }
            
            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Check if hit any animal
                animals.forEach((animal, index) => {
                    const distance = Math.sqrt(Math.pow(x - animal.x, 2) + Math.pow(y - animal.y, 2));
                    if (distance < animal.size) {
                        animals.splice(index, 1);
                        score += 10;
                        
                        // Add new animal
                        animals.push({
                            x: Math.random() * canvas.width,
                            y: Math.random() * canvas.height,
                            size: 30,
                            speed: 2 + Math.random() * 2,
                            direction: Math.random() * Math.PI * 2
                        });
                    }
                });
            });
            
            drawHuntingGame();
        }

        // Pet system
        function summonPet() {
            const petItem = game.player.inventory.find(item => item.type === 'pet' && !item.active);
            if (petItem) {
                const petData = game.pets.find(pet => pet.userData.name === petItem.name.split(' ')[0]);
                if (petData) {
                    game.player.pet = petData;
                    petData.userData.owner = game.player;
                    petItem.active = true;
                    document.getElementById('petHUD').style.display = 'block';
                    updatePetHUD();
                    showEventNotification('Pet Summoned', `${petData.userData.name} has joined you!`);
                }
            }
        }

        function updatePetHUD() {
            if (game.player.pet) {
                const pet = game.player.pet.userData;
                document.getElementById('petHealthText').textContent = `${pet.health}/${pet.maxHealth}`;
                document.getElementById('petHealthFill').style.width = `${(pet.health / pet.maxHealth) * 100}%`;
                document.getElementById('petHappinessText').textContent = `${Math.floor(pet.happiness)}/${pet.maxHealth}`;
                document.getElementById('petHappinessFill').style.width = `${(pet.happiness / pet.maxHealth) * 100}%`;
            }
        }

        // Mount system
        function summonMount() {
            const mountItem = game.player.inventory.find(item => item.type === 'mount' && !item.active);
            if (mountItem) {
                const mountData = game.mounts.find(mount => mount.userData.name === mountItem.name.split(' ')[0]);
                if (mountData) {
                    game.player.mount = mountData;
                    mountData.userData.owner = game.player;
                    mountItem.active = true;
                    showEventNotification('Mount Summoned', `${mountData.userData.name} is ready to ride!`);
                }
            }
        }

        function mountCreature() {
            if (game.player.mount && !game.player.onMount) {
                game.player.onMount = true;
                game.player.mount.position.copy(game.player.mesh.position);
                game.player.mount.position.y -= 1;
                document.getElementById('mountHUD').style.display = 'block';
                updateMountHUD();
                showEventNotification('Mount Mounted', `You are now riding ${game.player.mount.userData.name}!`);
            }
        }

        function dismountCreature() {
            if (game.player.onMount) {
                game.player.onMount = false;
                document.getElementById('mountHUD').style.display = 'none';
                showEventNotification('Mount Dismounted', 'You dismounted your creature.');
            }
        }

        function updateMountHUD() {
            if (game.player.mount) {
                const mount = game.player.mount.userData;
                document.getElementById('mountStaminaText').textContent = `${Math.floor(mount.stamina)}/${mount.maxStamina}`;
                document.getElementById('mountStaminaFill').style.width = `${(mount.stamina / mount.maxStamina) * 100}%`;
            }
        }

        // Inventory management
        let currentInventoryTab = 'items';
        function switchInventoryTab(tab) {
            currentInventoryTab = tab;
            document.querySelectorAll('.inventory-tab').forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');
            renderInventory();
        }

        function openInventory() {
            document.getElementById('inventory').style.display = 'block';
            renderInventory();
        }

        function closeInventory() {
            document.getElementById('inventory').style.display = 'none';
        }

        function renderInventory() {
            const grid = document.getElementById('inventoryGrid');
            grid.innerHTML = '';
            
            const filteredItems = game.player.inventory.filter(item => {
                if (currentInventoryTab === 'items') return item.type === 'consumable' || item.type === 'quest';
                if (currentInventoryTab === 'weapons') return item.type === 'weapon';
                if (currentInventoryTab === 'armor') return item.type === 'armor';
                if (currentInventoryTab === 'pets') return item.type === 'pet';
                if (currentInventoryTab === 'mounts') return item.type === 'mount';
                return true;
            });
            
            filteredItems.forEach((item, index) => {
                const slot = document.createElement('div');
                slot.className = 'inventorySlot';
                if (item.equipped) slot.classList.add('equipped');
                slot.innerHTML = `
                    ${item.icon}
                    ${item.quantity > 1 ? `<span style="position: absolute; bottom: 2px; right: 2px; font-size: 12px;">${item.quantity}</span>` : ''}
                `;
                slot.onclick = () => useItem(item);
                grid.appendChild(slot);
            });
        }

        function useItem(item) {
            if (item.type === 'consumable') {
                console.log(`Used ${item.name}`);
                if (item.name === 'Health Potion') {
                    game.player.health = Math.min(game.player.maxHealth, game.player.health + 30);
                    updateHealth();
                }
                if (item.quantity > 1) {
                    item.quantity--;
                } else {
                    game.player.inventory = game.player.inventory.filter(i => i.id !== item.id);
                }
                renderInventory();
            } else if (item.type === 'weapon') {
                // Equip weapon
                game.player.inventory.forEach(i => i.equipped = false);
                item.equipped = true;
                renderInventory();
            } else if (item.type === 'pet') {
                summonPet();
            } else if (item.type === 'mount') {
                summonMount();
            }
        }

        // Other UI functions (similar to previous implementation)
        function interact() {
            // ... (enhanced to handle pets and mounts)
        }

        function showDialogue(npcData) {
            // ... (similar to previous implementation)
        }

        function closeDialogue() {
            // ... (similar to previous implementation)
        }

        function enterVehicle(vehicle) {
            // ... (similar to previous implementation)
        }

        function exitVehicle() {
            // ... (similar to previous implementation)
        }

        function openMap() {
            // ... (similar to previous implementation)
        }

        function closeMap() {
            // ... (similar to previous implementation)
        }

        function fastTravel(location) {
            // ... (similar to previous implementation)
        }

        function playSound(soundName) {
            // ... (similar to previous implementation)
        }

        function toggleSound() {
            // ... (similar to previous implementation)
        }

        function takeDamage(amount) {
            // ... (similar to previous implementation)
        }

        function updateHealth() {
            // ... (similar to previous implementation)
        }

        function updateStamina() {
            // ... (similar to previous implementation)
        }

        function updateAmmo() {
            // ... (similar to previous implementation)
        }

        function updateCompanionHealth() {
            // ... (similar to previous implementation)
        }

        // Ultimate game loop
        function animate() {
            requestAnimationFrame(animate);
            
            const deltaTime = game.clock.getDelta();
            
            // Update physics
            game.world.step(1/60, deltaTime, 3);
            
            updateMovement(deltaTime);
            updateEnemies(deltaTime);
            updateCompanions(deltaTime);
            updatePets(deltaTime);
            updateMounts(deltaTime);
            updateParticles(deltaTime);
            updateMinimap();
            updateDayNightCycle(deltaTime);
            updateCompanionHealth();
            updatePlayTime(deltaTime);
            
            // Update ability cooldowns
            Object.keys(game.abilities).forEach(key => {
                const ability = game.abilities[key];
                if (ability.cooldown > 0) {
                    ability.cooldown -= deltaTime * 1000;
                    const overlay = document.querySelector(`[data-ability="${key}"] .cooldown-overlay`);
                    if (overlay) {
                        const percent = Math.max(0, ability.cooldown / ability.maxCooldown);
                        overlay.style.height = (percent * 100) + '%';
                    }
                }
            });
            
            // Update vehicle speed
            if (game.player.inVehicle && game.player.vehicle) {
                game.player.vehicle.userData.speed = Math.min(
                    game.player.vehicle.userData.maxSpeed,
                    game.player.vehicle.userData.speed + 50 * deltaTime
                );
                document.getElementById('speed').textContent = Math.floor(game.player.vehicle.userData.speed);
            }
            
            game.renderer.render(game.scene, game.camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            game.camera.aspect = window.innerWidth / window.innerHeight;
            game.camera.updateProjectionMatrix();
            game.renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Auto-save every 30 seconds
        setInterval(() => {
            if (game.gameMode === 'story') {
                saveGame(1);
                console.log('Auto-saved game!');
            }
        }, 30000);

        // Test functions
        setTimeout(() => {
            takeDamage(20);
            checkAchievement('first_kill', true);
        }, 2000);
        
        setTimeout(() => {
            const quest = game.quests.find(q => q.id === 1);
            if (quest && !quest.completed) {
                quest.completed = true;
                document.querySelector(`[data-quest="${quest.id}"]`).textContent = `[Completed] ${quest.name}`;
                gainXP(100);
                game.player.stats.questsCompleted++;
                console.log(`Quest completed: ${quest.name}`);
            }
        }, 5000);
    </script>
</body>
</html>
